<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VR Combat Playground</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial; }
        #info { 
            position: absolute; top: 10px; left: 10px; 
            color: white; background: rgba(0,0,0,0.8); 
            padding: 15px; border-radius: 8px; z-index: 100; 
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>VR Combat Playground</strong><br>
        Click to grab swords and throw at NPCs!<br>
        NPCs have health bars above their heads<br>
        Right-click: Rotate view | Scroll: Zoom
    </div>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 0, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 3, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.update();

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(5, 10, 5);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(50, 50),
            new THREE.MeshStandardMaterial({ color: 0x4a7c59 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const gravity = -9.8;
        const physicsObjects = [];
        const npcs = [];
        let draggedObject = null;

        class PhysicsObject {
            constructor(mesh, type = 'object') {
                this.mesh = mesh;
                this.type = type;
                this.velocity = new THREE.Vector3();
                this.isGrabbed = false;
                physicsObjects.push(this);
            }

            update(deltaTime) {
                if (this.isGrabbed) return;
                this.velocity.y += gravity * deltaTime;
                this.mesh.position.addScaledVector(this.velocity, deltaTime);
                
                if (this.mesh.position.y < 0.75) {
                    this.mesh.position.y = 0.75;
                    this.velocity.y = Math.abs(this.velocity.y) * 0.5;
                    this.velocity.x *= 0.8;
                    this.velocity.z *= 0.8;
                }
                
                this.velocity.multiplyScalar(0.99);
            }

            grab() { 
                this.isGrabbed = true; 
                this.velocity.set(0, 0, 0); 
            }
            
            release(throwVelocity) { 
                this.isGrabbed = false; 
                this.velocity.copy(throwVelocity); 
            }
        }

        class NPC {
            constructor(x, z, color) {
                this.group = new THREE.Group();
                this.health = 100;
                this.color = color;
                
                const body = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 1, 8),
                    new THREE.MeshStandardMaterial({ color })
                );
                body.position.y = 1;
                body.castShadow = true;
                this.body = body;
                this.group.add(body);
                
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.25, 16, 16),
                    new THREE.MeshStandardMaterial({ color: 0xffdbac })
                );
                head.position.y = 1.7;
                head.castShadow = true;
                this.group.add(head);
                
                const leftEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x000000 })
                );
                leftEye.position.set(-0.1, 1.75, 0.2);
                this.group.add(leftEye);
                
                const rightEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x000000 })
                );
                rightEye.position.set(0.1, 1.75, 0.2);
                this.group.add(rightEye);
                
                this.leftArm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8),
                    new THREE.MeshStandardMaterial({ color })
                );
                this.leftArm.position.set(-0.4, 1, 0);
                this.leftArm.rotation.z = 0.3;
                this.leftArm.castShadow = true;
                this.group.add(this.leftArm);
                
                this.rightArm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8),
                    new THREE.MeshStandardMaterial({ color })
                );
                this.rightArm.position.set(0.4, 1, 0);
                this.rightArm.rotation.z = -0.3;
                this.rightArm.castShadow = true;
                this.group.add(this.rightArm);
                
                this.healthBarGroup = new THREE.Group();
                const healthBg = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.6, 0.1),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                this.healthBarGroup.add(healthBg);
                
                this.healthBar = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.58, 0.08),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                );
                this.healthBar.position.z = 0.01;
                this.healthBarGroup.add(this.healthBar);
                this.healthBarGroup.position.y = 2.2;
                this.group.add(this.healthBarGroup);
                
                this.group.position.set(x, 0, z);
                scene.add(this.group);
                
                this.time = Math.random() * 100;
                this.direction = Math.random() * Math.PI * 2;
                npcs.push(this);
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.health < 0) this.health = 0;
                
                const healthPercent = this.health / 100;
                this.healthBar.scale.x = healthPercent;
                this.healthBar.position.x = -0.29 * (1 - healthPercent);
                
                if (healthPercent > 0.5) {
                    this.healthBar.material.color.setHex(0x00ff00);
                } else if (healthPercent > 0.25) {
                    this.healthBar.material.color.setHex(0xffff00);
                } else {
                    this.healthBar.material.color.setHex(0xff0000);
                }
                
                if (this.health <= 0) {
                    this.group.rotation.x = Math.PI / 2;
                    setTimeout(() => {
                        scene.remove(this.group);
                        const index = npcs.indexOf(this);
                        if (index > -1) npcs.splice(index, 1);
                    }, 2000);
                } else {
                    this.body.material.color.setHex(0xffffff);
                    setTimeout(() => {
                        this.body.material.color.setHex(this.color);
                    }, 100);
                }
            }

            update(deltaTime) {
                if (this.health <= 0) return;
                
                this.time += deltaTime;
                this.leftArm.rotation.x = Math.sin(this.time * 3) * 0.3;
                this.rightArm.rotation.x = -Math.sin(this.time * 3) * 0.3;
                this.group.position.y = Math.sin(this.time * 4) * 0.05;
                
                this.group.position.x += Math.cos(this.direction) * 0.3 * deltaTime;
                this.group.position.z += Math.sin(this.direction) * 0.3 * deltaTime;
                
                if (Math.abs(this.group.position.x) > 20 || Math.abs(this.group.position.z) > 20) {
                    this.direction += Math.PI;
                }
                
                if (Math.random() < 0.01) {
                    this.direction += (Math.random() - 0.5) * 0.5;
                }
                
                this.group.rotation.y = this.direction + Math.PI / 2;
                this.healthBarGroup.quaternion.copy(camera.quaternion);
            }
        }

        function createSword(x, y, z, color) {
            const swordGroup = new THREE.Group();
            
            const blade = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 1.5, 0.05),
                new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8 })
            );
            blade.position.y = 0.75;
            blade.castShadow = true;
            swordGroup.add(blade);
            
            const handle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 0.4, 8),
                new THREE.MeshStandardMaterial({ color })
            );
            handle.castShadow = true;
            swordGroup.add(handle);
            
            const guard = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.05, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x8b7355 })
            );
            guard.position.y = 0.2;
            guard.castShadow = true;
            swordGroup.add(guard);
            
            const pommel = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 8, 8),
                new THREE.MeshStandardMaterial({ color })
            );
            pommel.position.y = -0.25;
            pommel.castShadow = true;
            swordGroup.add(pommel);
            
            swordGroup.position.set(x, y, z);
            scene.add(swordGroup);
            
            return new PhysicsObject(swordGroup, 'sword');
        }

        new NPC(-5, -5, 0xff0000);
        new NPC(5, -5, 0x0000ff);
        new NPC(-5, 5, 0x00ff00);
        new NPC(5, 5, 0xffff00);
        new NPC(0, -8, 0xff00ff);
        new NPC(0, 8, 0x00ffff);

        createSword(-2, 1.5, 0, 0xff0000);
        createSword(2, 1.5, 0, 0x0000ff);
        createSword(0, 1.5, -2, 0x00ff00);
        createSword(0, 1.5, 2, 0xffff00);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let dragPlane = new THREE.Plane();
        let dragOffset = new THREE.Vector3();
        let previousMousePosition = new THREE.Vector2();
        let mouseVelocity = new THREE.Vector2();

        function checkSwordCollisions() {
            physicsObjects.forEach(obj => {
                if (obj.type === 'sword' && obj.velocity.length() > 2) {
                    npcs.forEach(npc => {
                        const distance = obj.mesh.position.distanceTo(npc.group.position);
                        if (distance < 1) {
                            npc.takeDamage(20);
                        }
                    });
                }
            });
        }

        renderer.domElement.addEventListener('mousedown', (event) => {
            if (event.button !== 0) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(physicsObjects.map(obj => obj.mesh), true);
            
            if (intersects.length > 0) {
                controls.enabled = false;
                let parentObj = intersects[0].object;
                while (parentObj.parent && !parentObj.parent.isScene) {
                    parentObj = parentObj.parent;
                }
                const physicsObj = physicsObjects.find(obj => obj.mesh === parentObj);
                
                if (physicsObj) {
                    draggedObject = physicsObj;
                    physicsObj.grab();
                    const cameraDirection = new THREE.Vector3();
                    camera.getWorldDirection(cameraDirection);
                    dragPlane.setFromNormalAndCoplanarPoint(cameraDirection, physicsObj.mesh.position);
                    const intersection = new THREE.Vector3();
                    raycaster.ray.intersectPlane(dragPlane, intersection);
                    dragOffset.subVectors(physicsObj.mesh.position, intersection);
                }
            }
            previousMousePosition.set(event.clientX, event.clientY);
        });

        renderer.domElement.addEventListener('mousemove', (event) => {
            if (draggedObject) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersection);
                draggedObject.mesh.position.copy(intersection.add(dragOffset));
                mouseVelocity.set(event.clientX - previousMousePosition.x, event.clientY - previousMousePosition.y);
                previousMousePosition.set(event.clientX, event.clientY);
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            if (draggedObject) {
                const throwVelocity = new THREE.Vector3(mouseVelocity.x * 0.05, -mouseVelocity.y * 0.05, 0);
                const cameraRight = new THREE.Vector3();
                const cameraUp = new THREE.Vector3();
                camera.getWorldDirection(cameraRight);
                cameraUp.copy(camera.up);
                cameraRight.cross(cameraUp).normalize();
                const worldVelocity = new THREE.Vector3();
                worldVelocity.addScaledVector(cameraRight, throwVelocity.x);
                worldVelocity.addScaledVector(cameraUp, throwVelocity.y);
                draggedObject.release(worldVelocity);
                draggedObject = null;
                controls.enabled = true;
            }
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1);
            physicsObjects.forEach(obj => obj.update(deltaTime));
            npcs.forEach(npc => npc.update(deltaTime));
            checkSwordCollisions();
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
