<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>VR Mega Sandbox - Absolute Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #info { 
            position: absolute; top: 20px; left: 20px; color: #00ffff; 
            background: rgba(0,0,0,0.85); padding: 20px; border: 2px solid #00ffff;
            border-radius: 10px; font-family: 'Courier New', monospace; font-size: 14px;
            pointer-events: none; text-shadow: 0 0 5px #00ffff;
        }
    </style>
</head>
<body>
    <div id="info">
        <b>SYSTEM STATUS: ULTIMATE SANDBOX</b><br><br>
        [L-STICK] : MOVE AVATAR<br>
        [R-STICK] : SNAP TURN<br>
        [GRIP]    : PICK UP / ZIPLINE / THROW<br>
        [TRIGGER] : FIRE GUN / WELD BLOCKS<br>
        [WAIST]   : GRAB AMMO (CYAN BOX)<br><br>
        BUILD MODE: USE WELDER TO JOIN BLOCKS
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        // ==========================================
        // 1. ENGINE CORE
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 20, 150);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const cameraGroup = new THREE.Group();
        cameraGroup.add(camera);
        scene.add(cameraGroup);

        // ==========================================
        // 2. LIGHTING & ENVIRONMENT
        // ==========================================
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);

        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.set(2048, 2048);
        scene.add(sun);

        const groundGeo = new THREE.PlaneGeometry(500, 500);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x448844, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // ==========================================
        // 3. ENHANCED PHYSICS & WELDING SYSTEM
        // ==========================================
        const physicsObjects = [];
        class PhysicsObject {
            constructor(mesh, type = 'prop') {
                this.mesh = mesh;
                this.type = type;
                this.velocity = new THREE.Vector3();
                this.isGrabbed = false;
                this.isWeldedTo = null; // Parent object if welded
                this.lastPos = new THREE.Vector3();
                this.ammoCount = 0;
                this.isDead = false;
                physicsObjects.push(this);
            }

            update(dt) {
                if (this.isGrabbed || this.isWeldedTo || this.isDead) {
                    if (this.isGrabbed) {
                        const cur = new THREE.Vector3().setFromMatrixPosition(this.mesh.matrixWorld);
                        this.velocity.subVectors(cur, this.lastPos).divideScalar(dt);
                        this.lastPos.copy(cur);
                    }
                    return;
                }

                // Gravity logic
                this.velocity.y -= 9.8 * dt;
                this.mesh.position.addScaledVector(this.velocity, dt);

                // Ground Collision
                if (this.mesh.position.y < 0.1) {
                    this.mesh.position.y = 0.1;
                    this.velocity.set(0, 0, 0);
                }

                // Air Drag
                this.velocity.multiplyScalar(0.985);
            }
        }

        // ==========================================
        // 4. THE PLAYGROUND (GEOMETRY HEAVY)
        // ==========================================
        
        // --- THE SLIDE ---
        const slideArea = new THREE.Group();
        const s_Platform = new THREE.Mesh(new THREE.BoxGeometry(4, 0.4, 4), new THREE.MeshStandardMaterial({color: 0xcc4400}));
        s_Platform.position.y = 4;
        const s_Ramp = new THREE.Mesh(new THREE.BoxGeometry(4, 0.4, 8), new THREE.MeshStandardMaterial({color: 0xffaa00}));
        s_Ramp.position.set(0, 2, 4.5); s_Ramp.rotation.x = -0.45;
        const s_Leg1 = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 4), new THREE.MeshStandardMaterial({color: 0x555555}));
        s_Leg1.position.set(1.5, 2, 1.5);
        const s_Leg2 = s_Leg1.clone(); s_Leg2.position.set(-1.5, 2, 1.5);
        const s_Leg3 = s_Leg1.clone(); s_Leg3.position.set(1.5, 2, -1.5);
        const s_Leg4 = s_Leg1.clone(); s_Leg4.position.set(-1.5, 2, -1.5);
        slideArea.add(s_Platform, s_Ramp, s_Leg1, s_Leg2, s_Leg3, s_Leg4);
        slideArea.position.set(-20, 0, -20);
        scene.add(slideArea);

        // --- MERRY-GO-ROUND ---
        const mgr = new THREE.Group();
        const mg_Base = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 0.25, 32), new THREE.MeshStandardMaterial({ color: 0xaa00aa }));
        mgr.add(mg_Base);
        const mg_Handles = [];
        for (let i = 0; i < 6; i++) {
            const h_Group = new THREE.Group();
            const h_Pole = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1.5), new THREE.MeshStandardMaterial({color: 0xeeeeee}));
            const h_Top = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.08, 0.08), new THREE.MeshStandardMaterial({color: 0xeeeeee}));
            h_Top.position.y = 0.75;
            h_Group.add(h_Pole, h_Top);
            const ang = (i / 6) * Math.PI * 2;
            h_Group.position.set(Math.cos(ang)*3.2, 0.75, Math.sin(ang)*3.2);
            mgr.add(h_Group); mg_Handles.push(h_Group);
        }
        mgr.position.set(0, 0.1, -25);
        scene.add(mgr);

        // --- SWING SET ---
        const swings = new THREE.Group();
        const sw_Frame = new THREE.Mesh(new THREE.BoxGeometry(10, 0.3, 0.3), new THREE.MeshStandardMaterial({color: 0x442200}));
        sw_Frame.position.y = 5;
        const sw_P1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 6), new THREE.MeshStandardMaterial({color: 0x442200}));
        sw_P1.position.set(4.5, 2.5, 0); sw_P1.rotation.z = 0.2;
        const sw_P2 = sw_P1.clone(); sw_P2.position.set(-4.5, 2.5, 0); sw_P2.rotation.z = -0.2;
        swings.add(sw_Frame, sw_P1, sw_P2);
        swings.position.set(20, 0, -20);
        scene.add(swings);

        // ==========================================
        // 5. THE NEIGHBORHOOD (HOUSES)
        // ==========================================
        function createHouse(x, z, hColor) {
            const h = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(8, 6, 8), new THREE.MeshStandardMaterial({color: 0xdddddd}));
            body.position.y = 3;
            const roof = new THREE.Mesh(new THREE.ConeGeometry(7, 4, 4), new THREE.MeshStandardMaterial({color: hColor}));
            roof.position.y = 8; roof.rotation.y = Math.PI/4;
            const door = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.5, 0.2), new THREE.MeshStandardMaterial({color: 0x442200}));
            door.position.set(0, 1.25, 4);
            h.add(body, roof, door);
            h.position.set(x, 0, z);
            scene.add(h);
        }
        createHouse(-50, 0, 0x880000);
        createHouse(-50, 20, 0x000088);
        createHouse(-50, -20, 0x006600);

        // ==========================================
        // 6. ZIPLINE SYSTEM
        // ==========================================
        const ziplines = [];
        function createZipline(startX, startZ, endX, endZ) {
            const pole_geo = new THREE.CylinderGeometry(0.3, 0.3, 12);
            const pole_mat = new THREE.MeshStandardMaterial({color: 0x333333});
            const p1 = new THREE.Mesh(pole_geo, pole_mat); p1.position.set(startX, 6, startZ);
            const p2 = new THREE.Mesh(pole_geo, pole_mat); p2.position.set(endX, 6, endZ);
            scene.add(p1, p2);

            const handle = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshStandardMaterial({color: 0xffff00, emissive: 0x444400}));
            handle.position.set(startX, 11, startZ);
            scene.add(handle);
            const po = new PhysicsObject(handle, 'zip');
            po.start = new THREE.Vector3(startX, 11, startZ);
            po.end = new THREE.Vector3(endX, 11, endZ);
            ziplines.push(po);
        }
        createZipline(30, -30, 30, 60);

        // ==========================================
        // 7. ARSENAL & TOOLS
        // ==========================================
        
        function spawnGun(x, z) {
            const g = new THREE.Group();
            const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, 0.3), new THREE.MeshStandardMaterial({color: 0x222222}));
            const grip = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.15, 0.07), new THREE.MeshStandardMaterial({color: 0x222222}));
            grip.position.set(0, -0.1, 0.1);
            g.add(barrel, grip); g.position.set(x, 1, z);
            scene.add(g);
            const po = new PhysicsObject(g, 'gun'); po.ammoCount = 0;
        }

        function spawnSword(x, z) {
            const g = new THREE.Group();
            const blade = new THREE.Mesh(new THREE.BoxGeometry(0.02, 1.0, 0.08), new THREE.MeshStandardMaterial({color: 0xdddddd, metalness: 0.9, roughness: 0.1}));
            blade.position.y = 0.55;
            const hilt = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.25), new THREE.MeshStandardMaterial({color: 0x331100}));
            const cross = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.03, 0.05), new THREE.MeshStandardMaterial({color: 0xaa8800}));
            cross.position.y = 0.1;
            g.add(blade, hilt, cross); g.position.set(x, 1, z);
            scene.add(g);
            new PhysicsObject(g, 'sword');
        }

        function spawnWelder(x, z) {
            const g = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.06, 0.35), new THREE.MeshStandardMaterial({color: 0x0088ff}));
            const tip = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.1), new THREE.MeshStandardMaterial({color: 0xffffff, emissive: 0x00ffff}));
            tip.position.y = 0.2; body.rotation.x = Math.PI/2;
            g.add(body, tip); g.position.set(x, 1, z);
            scene.add(g);
            new PhysicsObject(g, 'welder');
        }

        spawnGun(2, 2); spawnSword(-2, 2); spawnWelder(0, 3);

        // Car Building Blocks
        for(let i=0; i<8; i++) {
            const b = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({color: Math.random()*0xffffff}));
            b.position.set(5 + Math.random()*5, 0.5, 5 + Math.random()*5);
            scene.add(b); new PhysicsObject(b, 'block');
        }

        // ==========================================
        // 8. NPCs & HEALTH
        // ==========================================
        const npcs = [];
        function createNPC(x, z) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 1.2), new THREE.MeshStandardMaterial({color: 0xff3333}));
            body.position.y = 1;
            const hb_bg = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.08), new THREE.MeshBasicMaterial({color: 0x330000}));
            hb_bg.position.y = 2.4;
            const hb_fg = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.08), new THREE.MeshBasicMaterial({color: 0x00ff00}));
            hb_fg.position.y = 2.41; hb_fg.position.z = 0.01;
            group.add(body, hb_bg, hb_fg);
            group.position.set(x, 0, z);
            group.userData = { health: 100, bar: hb_fg, dir: Math.random()*Math.PI*2 };
            scene.add(group); npcs.push(group);
        }
        for(let i=0; i<5; i++) createNPC(Math.random()*40-20, -40 - Math.random()*10);

        // ==========================================
        // 9. VR INPUT & LOGIC
        // ==========================================
        const modelFactory = new XRControllerModelFactory();
        const ammoSpawner = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.12, 0.12), new THREE.MeshStandardMaterial({color: 0x00ffff, wireframe: true}));
        scene.add(ammoSpawner);

        let activeMGHand = null, lastMGAngle = 0, mgVel = 0;

        function onSqueezeStart(e) {
            const c = e.target;
            const hPos = new THREE.Vector3().setFromMatrixPosition(c.matrixWorld);

            // Ammo Pick
            if(hPos.distanceTo(ammoSpawner.position) < 0.22) {
                const m = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.12, 0.05), new THREE.MeshStandardMaterial({color: 0xffaa00}));
                scene.add(m); const po = new PhysicsObject(m, 'ammo');
                c.attach(m); c.userData.selected = po; po.isGrabbed = true;
                return;
            }

            // Object Pick
            physicsObjects.forEach(obj => {
                const oPos = new THREE.Vector3().setFromMatrixPosition(obj.mesh.matrixWorld);
                if(hPos.distanceTo(oPos) < 0.45) {
                    obj.isGrabbed = true; c.attach(obj.mesh); c.userData.selected = obj;
                }
            });

            // Merry-Go-Round Grab
            mg_Handles.forEach(h => {
                if(hPos.distanceTo(h.getWorldPosition(new THREE.Vector3())) < 0.4) {
                    activeMGHand = c;
                    const loc = mgr.worldToLocal(hPos.clone());
                    lastMGAngle = Math.atan2(loc.z, loc.x);
                }
            });
        }

        function onSqueezeEnd(e) {
            const c = e.target;
            if(activeMGHand === c) activeMGHand = null;
            if(c.userData.selected) {
                const obj = c.userData.selected;
                scene.attach(obj.mesh); obj.isGrabbed = false;
                c.userData.selected = null;
            }
        }

        function onSelectStart(e) {
            const c = e.target;
            const held = c.userData.selected;
            if(held && held.type === 'gun' && held.ammoCount > 0) {
                const b = new THREE.Mesh(new THREE.SphereGeometry(0.04), new THREE.MeshBasicMaterial({color: 0xffff00}));
                b.position.setFromMatrixPosition(c.matrixWorld); scene.add(b);
                const pb = new PhysicsObject(b, 'bullet');
                const dir = new THREE.Vector3(0,0,-1).applyQuaternion(c.quaternion).normalize();
                pb.velocity.copy(dir.multiplyScalar(60)); held.ammoCount--;
            }
            if(held && held.type === 'welder') {
                let nearby = physicsObjects.filter(o => o.type === 'block' && o.mesh.position.distanceTo(held.mesh.position) < 0.6);
                if(nearby.length >= 2) {
                    nearby[0].mesh.attach(nearby[1].mesh); nearby[1].isWeldedTo = nearby[0];
                }
            }
        }

        for (let i = 0; i < 2; i++) {
            const c = renderer.xr.getController(i);
            c.addEventListener('squeezestart', onSqueezeStart);
            c.addEventListener('squeezeend', onSqueezeEnd);
            c.addEventListener('selectstart', onSelectStart);
            cameraGroup.add(c);
            const g = renderer.xr.getControllerGrip(i);
            g.add(modelFactory.createControllerModel(g));
            cameraGroup.add(g);
        }

        // ==========================================
        // 10. MAIN ANIMATION & LOGIC LOOP
        // ==========================================
        const clock = new THREE.Clock();
        renderer.setAnimationLoop(() => {
            const dt = Math.min(clock.getDelta(), 0.1);
            const session = renderer.xr.getSession();

            // --- THUMBSTICK LOCOMOTION ---
            if (session) {
                for (const source of session.inputSources) {
                    if (source.gamepad) {
                        const axes = source.gamepad.axes;
                        if (source.handedness === 'left') {
                            const headYaw = camera.rotation.y;
                            cameraGroup.position.x += (axes[2] * Math.cos(headYaw) + axes[3] * Math.sin(headYaw)) * 4 * dt;
                            cameraGroup.position.z += (axes[3] * Math.cos(headYaw) - axes[2] * Math.sin(headYaw)) * 4 * dt;
                        } else if (source.handedness === 'right') {
                            if (Math.abs(axes[2]) > 0.5) cameraGroup.rotation.y -= Math.sign(axes[2]) * 0.05;
                        }
                    }
                }
            }

            // --- AMMO SPAWNER SYNC ---
            const hWorld = new THREE.Vector3(); camera.getWorldPosition(hWorld);
            ammoSpawner.position.set(hWorld.x, hWorld.y - 0.75, hWorld.z);
            ammoSpawner.rotation.y = camera.rotation.y;

            // --- MERRY-GO-ROUND SPIN ---
            if(activeMGHand) {
                const loc = mgr.worldToLocal(new THREE.Vector3().setFromMatrixPosition(activeMGHand.matrixWorld));
                const cur = Math.atan2(loc.z, loc.x);
                mgVel = (cur - lastMGAngle) / dt; lastMGAngle = cur;
            }
            mgr.rotation.y += mgVel * dt; mgVel *= 0.985;

            // --- PHYSICS & INTERACTION LOGIC ---
            physicsObjects.forEach(o => {
                if(o.isDead) return;
                o.update(dt);

                // Reload Gun
                if(o.type === 'ammo' && o.isGrabbed) {
                    physicsObjects.forEach(g => { 
                        if(g.type === 'gun' && o.mesh.position.distanceTo(g.mesh.position) < 0.25) { 
                            g.ammoCount = 15; scene.remove(o.mesh); o.isDead = true; 
                        }
                    });
                }

                // Bullet Impacts
                if(o.type === 'bullet') {
                    npcs.forEach(n => { 
                        if(o.mesh.position.distanceTo(n.position.clone().add(new THREE.Vector3(0,1,0))) < 0.7) { 
                            n.userData.health -= 25; 
                            n.userData.bar.scale.x = Math.max(0, n.userData.health/100); 
                            scene.remove(o.mesh); o.isDead = true; 
                        }
                    });
                }

                // Zipline Movement
                if(o.type === 'zip' && o.isGrabbed) {
                    const travel = new THREE.Vector3().subVectors(o.end, o.start).normalize();
                    o.mesh.position.addScaledVector(travel, 12 * dt);
                    cameraGroup.position.copy(o.mesh.position.clone().sub(new THREE.Vector3(0, 2.5, 0)));
                    if(o.mesh.position.distanceTo(o.end) < 0.5) { /* Optional: auto-drop */ }
                }
            });

            // --- NPC AI ---
            npcs.forEach(n => {
                if(n.userData.health <= 0) { n.rotation.x = Math.PI/2; return; }
                n.position.x += Math.cos(n.userData.dir) * 1.2 * dt;
                n.position.z += Math.sin(n.userData.dir) * 1.2 * dt;
                if(Math.abs(n.position.x) > 60 || Math.abs(n.position.z) > 60) n.userData.dir += Math.PI;
            });

            renderer.render(scene, camera);
        });
    </script>
</body>
</html>
