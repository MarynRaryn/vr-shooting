<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VR Combat - Hand Presence</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { overflow:hidden; background:#000; font-family:'Segoe UI',sans-serif; }

/* â”€â”€ HANDEDNESS SCREEN â”€â”€ */
#handedness-screen {
  position:absolute; inset:0;
  background:radial-gradient(ellipse at center, #0d1b2a 0%, #000 100%);
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  z-index:200; color:white;
}
#handedness-screen h1 {
  font-size:52px; font-weight:900; letter-spacing:5px; margin-bottom:10px;
  background:linear-gradient(90deg,#00e5ff,#7c4dff);
  -webkit-background-clip:text; -webkit-text-fill-color:transparent;
}
#handedness-screen p { opacity:0.6; margin-bottom:50px; font-size:16px; letter-spacing:2px; }
.hand-options { display:flex; gap:30px; }
.hand-btn {
  width:200px; height:220px; border:2px solid rgba(255,255,255,0.15);
  border-radius:20px; background:rgba(255,255,255,0.05);
  color:white; cursor:pointer; transition:all 0.25s;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap:16px; font-size:18px; font-weight:bold; letter-spacing:1px;
}
.hand-btn:hover { border-color:#00e5ff; background:rgba(0,229,255,0.1); transform:translateY(-6px); box-shadow:0 20px 40px rgba(0,229,255,0.3); }
.hand-icon { font-size:80px; }

/* â”€â”€ MODE SCREEN â”€â”€ */
#mode-screen {
  position:absolute; inset:0;
  background:radial-gradient(ellipse at center, #0d1b2a 0%, #000 100%);
  display:none; flex-direction:column; align-items:center; justify-content:center;
  z-index:190; color:white;
}
#mode-screen h2 { font-size:38px; font-weight:900; letter-spacing:4px; margin-bottom:10px; color:#00e5ff; }
#mode-screen p { opacity:0.6; margin-bottom:40px; font-size:15px; }
#handedness-display { font-size:16px; opacity:0.5; margin-bottom:30px; }
.mode-options { display:flex; gap:24px; flex-wrap:wrap; justify-content:center; }
.mode-btn {
  padding:18px 36px; font-size:18px; font-weight:bold; border:none;
  border-radius:12px; cursor:pointer; letter-spacing:2px; transition:all 0.2s;
}
#vr-mode-btn { background:linear-gradient(135deg,#7c4dff,#00e5ff); color:white; box-shadow:0 0 30px rgba(124,77,255,0.5); }
#vr-mode-btn:hover { transform:scale(1.06); }
#desktop-mode-btn { background:rgba(255,255,255,0.08); color:white; border:2px solid rgba(255,255,255,0.2); }
#desktop-mode-btn:hover { background:rgba(255,255,255,0.15); }
#vr-check-status { margin-top:18px; font-size:13px; opacity:0.45; }

/* â”€â”€ HUD â”€â”€ */
#hud { position:absolute; inset:0; pointer-events:none; z-index:10; display:none; }
#ammo-display {
  position:absolute; bottom:30px; right:30px;
  color:#fff; font-size:24px; font-weight:bold;
  text-shadow:0 0 15px #00e5ff;
  background:rgba(0,0,0,0.65); padding:10px 22px;
  border-radius:10px; border:1px solid rgba(0,229,255,0.35);
}
#score-hud {
  position:absolute; top:20px; left:20px;
  color:#fff; font-size:15px; font-weight:bold;
  background:rgba(0,0,0,0.65); padding:12px 18px;
  border-radius:10px; border:1px solid rgba(255,255,255,0.12);
  line-height:2;
}
#weapon-hud {
  position:absolute; bottom:30px; left:30px;
  color:#fff; font-size:13px;
  background:rgba(0,0,0,0.65); padding:10px 16px;
  border-radius:10px; border:1px solid rgba(255,255,255,0.12);
  line-height:1.9;
}
#crosshair { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); }
#crosshair::before,#crosshair::after { content:''; position:absolute; background:rgba(255,255,255,0.85); border-radius:2px; }
#crosshair::before { width:2px; height:16px; top:-8px; left:-1px; }
#crosshair::after  { width:16px; height:2px; top:-1px; left:-8px; }
#hitmarker { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); opacity:0; transition:opacity 0.05s; }
#hitmarker.show { opacity:1; }
#hitmarker::before,#hitmarker::after { content:''; position:absolute; background:#ff1744; border-radius:2px; }
#hitmarker::before { width:2px; height:10px; top:-5px; left:-1px; }
#hitmarker::after  { width:10px; height:2px; top:-1px; left:-5px; }
#reload-bar { position:absolute; bottom:78px; right:30px; width:150px; height:7px; background:rgba(255,255,255,0.15); border-radius:4px; display:none; }
#reload-fill { height:100%; background:linear-gradient(90deg,#00e5ff,#7c4dff); border-radius:4px; width:0%; }
#wave-banner {
  position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
  font-size:48px; font-weight:900; color:white;
  text-shadow:0 0 40px #7c4dff; pointer-events:none; opacity:0; transition:opacity 0.5s;
}
#wave-banner.show { opacity:1; }
#vr-hint {
  position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
  color:white; font-size:16px; text-align:center;
  background:rgba(0,0,0,0.7); padding:20px 30px; border-radius:12px;
  border:1px solid rgba(255,255,255,0.2); line-height:2; display:none;
}
</style>
</head>
<body>

<!-- STEP 1: Choose handedness -->
<div id="handedness-screen">
  <h1>VR COMBAT</h1>
  <p>BEFORE WE BEGIN â€” CHOOSE YOUR DOMINANT HAND</p>
  <div class="hand-options">
    <button class="hand-btn" onclick="chooseHand('right')">
      <div class="hand-icon">ğŸ¤œ</div>
      RIGHT HANDED
      <small style="opacity:0.5;font-size:12px;font-weight:normal">Gun: Right hand<br>Free: Left hand</small>
    </button>
    <button class="hand-btn" onclick="chooseHand('left')">
      <div class="hand-icon">ğŸ¤›</div>
      LEFT HANDED
      <small style="opacity:0.5;font-size:12px;font-weight:normal">Gun: Left hand<br>Free: Right hand</small>
    </button>
  </div>
</div>

<!-- STEP 2: Choose VR or Desktop -->
<div id="mode-screen">
  <h2>READY TO PLAY</h2>
  <div id="handedness-display"></div>
  <p>Choose how to play</p>
  <div class="mode-options">
    <button class="mode-btn" id="vr-mode-btn" onclick="enterVR()">ğŸ¥½ ENTER VR</button>
    <button class="mode-btn" id="desktop-mode-btn" onclick="enterDesktop()">ğŸ–¥ï¸ DESKTOP</button>
  </div>
  <div id="vr-check-status">Checking VR...</div>
</div>

<!-- HUD -->
<div id="hud">
  <div id="crosshair"></div>
  <div id="hitmarker"></div>
  <div id="ammo-display">-- / --</div>
  <div id="reload-bar"><div id="reload-fill"></div></div>
  <div id="score-hud">
    ğŸ’€ Kills: <span id="kills">0</span><br>
    ğŸ¯ Score: <span id="scoreVal">0</span><br>
    â¤ï¸ HP: <span id="hp">100</span><br>
    ğŸŒŠ Wave: <span id="wave">1</span>
  </div>
  <div id="weapon-hud">
    <b>EQUIPPED:</b> <span id="eq-weapon">PISTOL</span><br>
    <span style="opacity:0.5">â–²â–¼ Thumbstick = Switch weapon</span><br>
    <span style="opacity:0.5">Grip = Grab nearby objects</span>
  </div>
  <div id="wave-banner"></div>
  <div id="vr-hint">
    ğŸ¥½ <b>VR CONTROLS</b><br>
    Gun hand Trigger = SHOOT<br>
    Gun hand Thumbstick â–²â–¼ = Switch weapon<br>
    Free hand Grip = Grab objects (close range!)<br>
    Left thumbstick = Move<br>
    Right thumbstick â—€â–¶ = Snap turn<br>
    <br>
    <span style="opacity:0.5">Reload: bring free hand to gun hand</span>
  </div>
</div>

<script type="importmap">
{"imports":{
  "three":"https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
  "three/addons/":"https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
}}
</script>
<script type="module">
import * as THREE from 'three';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let dominantHand = 'right'; // set by user
let gunHandIndex  = 1; // controller index: right=1, left=0
let freeHandIndex = 0;
let isVR = false;
let gameStarted = false;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDERER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.xr.enabled = true;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
document.body.appendChild(renderer.domElement);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SCENE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x7ecfea);
scene.fog = new THREE.FogExp2(0x7ecfea, 0.006);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAYER RIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const playerRig = new THREE.Group();
scene.add(playerRig);
playerRig.position.set(0, 0, 8);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.05, 400);
camera.position.set(0, 1.7, 0);
playerRig.add(camera);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIGHTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
scene.add(new THREE.AmbientLight(0xfff4e0, 0.45));
const sun = new THREE.DirectionalLight(0xfffde7, 1.0);
sun.position.set(60,80,40); sun.castShadow=true;
sun.shadow.mapSize.set(4096,4096);
sun.shadow.camera.left=-80; sun.shadow.camera.right=80;
sun.shadow.camera.top=80; sun.shadow.camera.bottom=-80;
sun.shadow.bias=-0.0005; scene.add(sun);
scene.add(new THREE.HemisphereLight(0x87ceeb,0x4a7a2a,0.4));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MATERIALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const M = {
  grass:   new THREE.MeshStandardMaterial({color:0x4caf50,roughness:0.9}),
  dirt:    new THREE.MeshStandardMaterial({color:0x6d4c41,roughness:1}),
  concrete:new THREE.MeshStandardMaterial({color:0x90a4ae,roughness:0.85}),
  metal:   new THREE.MeshStandardMaterial({color:0x546e7a,roughness:0.3,metalness:0.9}),
  wood:    new THREE.MeshStandardMaterial({color:0x8d6e63,roughness:0.9}),
  red:     new THREE.MeshStandardMaterial({color:0xef5350,roughness:0.7}),
  blue:    new THREE.MeshStandardMaterial({color:0x42a5f5,roughness:0.7}),
  yellow:  new THREE.MeshStandardMaterial({color:0xffee58,roughness:0.7}),
  orange:  new THREE.MeshStandardMaterial({color:0xffa726,roughness:0.7}),
  purple:  new THREE.MeshStandardMaterial({color:0xab47bc,roughness:0.7}),
  stone:   new THREE.MeshStandardMaterial({color:0x78909c,roughness:0.95}),
  brick:   new THREE.MeshStandardMaterial({color:0xc62828,roughness:0.9}),
  skin:    new THREE.MeshStandardMaterial({color:0xffcc99,roughness:0.8}),
  darkSkin:new THREE.MeshStandardMaterial({color:0xd4956a,roughness:0.8}),
  nail:    new THREE.MeshStandardMaterial({color:0xf5c5a3,roughness:0.7}),
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function box(w,h,d,mat,x,y,z,rx=0,ry=0){
  const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),mat);
  m.position.set(x,y,z); m.rotation.set(rx,ry,0);
  m.castShadow=true; m.receiveShadow=true; scene.add(m); return m;
}
function cyl(rt,rb,h,seg,mat,x,y,z,rx=0){
  const m=new THREE.Mesh(new THREE.CylinderGeometry(rt,rb,h,seg),mat);
  m.position.set(x,y,z); m.rotation.x=rx;
  m.castShadow=true; m.receiveShadow=true; scene.add(m); return m;
}
function sph(r,seg,mat,x,y,z){
  const m=new THREE.Mesh(new THREE.SphereGeometry(r,seg,seg),mat);
  m.position.set(x,y,z); m.castShadow=true; scene.add(m); return m;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GROUND + PATH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const ground=new THREE.Mesh(new THREE.PlaneGeometry(200,200),M.grass);
ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);
box(4,0.04,80,M.dirt,0,0.01,0);

// Boundary walls
[[0,1,55,110,2,1],[0,1,-55,110,2,1],[55,1,0,1,2,110],[-55,1,0,1,2,110]]
  .forEach(([x,y,z,w,h,d])=>box(w,h,d,M.concrete,x,y,z));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STONES (collidable)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const stoneObjects = []; // {mesh, radius}
function makeStone(x,z,r){
  const s=new THREE.Mesh(
    new THREE.SphereGeometry(r,10,8),
    new THREE.MeshStandardMaterial({color:0x78909c+(Math.random()>0.5?0x101010:0),roughness:0.95,metalness:0.05})
  );
  s.scale.set(1,0.65+Math.random()*0.3,1);
  s.position.set(x,r*0.4,z);
  s.castShadow=true; s.receiveShadow=true; scene.add(s);
  stoneObjects.push({mesh:s, radius:r});
  return s;
}
const stonePos = [
  [-5,3,1.2],[-8,-4,0.9],[4,3,1.5],[10,-7,0.8],[-12,2,1.1],
  [6,-2,0.7],[-3,-8,1.3],[15,5,1.0],[-18,3,0.9],[8,12,1.4],
  [-10,10,1.0],[14,-12,0.8],[-6,16,1.2],[3,-15,1.1],[20,2,0.9],
  [-22,-4,1.3],[12,8,0.7],[-14,-8,1.5],[18,-6,1.0],[-8,20,0.8]
];
stonePos.forEach(([x,z,r])=>makeStone(x,z,r));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DESTRUCTIBLE WALLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const destructibles=[];
function makeDestructWall(px,pz,ry=0){
  const g=new THREE.Group(); g.position.set(px,0,pz); g.rotation.y=ry; scene.add(g);
  const bm=new THREE.MeshStandardMaterial({color:0xc62828,roughness:0.9});
  for(let r=0;r<4;r++) for(let c=0;c<6;c++){
    const off=r%2===0?0:0.49;
    const br=new THREE.Mesh(new THREE.BoxGeometry(0.94,0.54,0.44),bm.clone());
    br.position.set(c*0.96-2.65+off,r*0.56+0.28,0);
    br.castShadow=true; br.receiveShadow=true;
    br.userData={vel:new THREE.Vector3(),avel:new THREE.Vector3(),falling:false,alive:true};
    g.add(br); destructibles.push({mesh:br});
  }
}
[[-14,-8,0],[-14,-13,0],[14,-8,0],[14,-13,0],[0,-22,Math.PI/2],[0,-27,Math.PI/2],[-7,-18,0],[7,-18,0]]
  .forEach(([x,z,r])=>makeDestructWall(x,z,r));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TARGETS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const targets=[];
function makeTarget(x,y,z,moving=false){
  const g=new THREE.Group(); g.position.set(x,y,z); scene.add(g);
  const post=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.07,y,8),M.wood.clone());
  post.position.y=-y/2; post.castShadow=true; g.add(post);
  [[0.65,0xd32f2f],[0.5,0xffffff],[0.35,0xd32f2f],[0.22,0xffffff],[0.09,0xd32f2f]].forEach(([r,c])=>{
    const ring=new THREE.Mesh(new THREE.CylinderGeometry(r,r,0.04,32),
      new THREE.MeshStandardMaterial({color:c,roughness:0.5}));
    ring.rotation.x=Math.PI/2; g.add(ring);
  });
  g.userData={health:3,alive:true,moving,baseX:x,phase:Math.random()*Math.PI*2,speed:0.4+Math.random()*0.8,range:2+Math.random()*2,spin:Math.random()>0.5,spinSpeed:(Math.random()-0.5)*1.5};
  targets.push(g); return g;
}
for(let i=0;i<7;i++) makeTarget(-14+i*4.5,1.6,-20);
for(let i=0;i<4;i++) makeTarget(-8+i*5,1.9,-32,true);
targets.forEach(t=>{t.userData.baseX=t.position.x;});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHYSICS OBJECTS (grabbable by free hand)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const physObjects=[];
const GRAB_RADIUS = 0.35; // very close grab range

function makePhys(mesh,type='block'){
  const p={mesh,vel:new THREE.Vector3(),avel:new THREE.Vector3(),grounded:false,heldBy:null,type};
  physObjects.push(p); return p;
}

function makeBlock(x,y,z,mat,w=1,h=1,d=1){
  const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),mat.clone());
  m.position.set(x,y,z); m.castShadow=true; m.receiveShadow=true; scene.add(m);
  return makePhys(m,'block');
}

function makeSword(x,y,z,bladeCol,handleCol){
  const g=new THREE.Group(); g.position.set(x,y,z); scene.add(g);
  const blade=new THREE.Mesh(new THREE.BoxGeometry(0.1,1.7,0.055),
    new THREE.MeshStandardMaterial({color:bladeCol,metalness:0.95,roughness:0.05,emissive:bladeCol,emissiveIntensity:0.12}));
  blade.position.y=0.85; blade.castShadow=true; g.add(blade);
  const handle=new THREE.Mesh(new THREE.CylinderGeometry(0.09,0.09,0.45,10),
    new THREE.MeshStandardMaterial({color:handleCol,roughness:0.6}));
  handle.castShadow=true; g.add(handle);
  const guard=new THREE.Mesh(new THREE.BoxGeometry(0.44,0.07,0.1),
    new THREE.MeshStandardMaterial({color:0x8d6e63,metalness:0.5}));
  guard.position.y=0.23; g.add(guard);
  const pommel=new THREE.Mesh(new THREE.SphereGeometry(0.11,10,10),
    new THREE.MeshStandardMaterial({color:handleCol,metalness:0.4}));
  pommel.position.y=-0.27; g.add(pommel);
  return makePhys(g,'sword');
}

const bmats=[M.red,M.blue,M.yellow,M.orange,M.purple,M.wood,M.concrete,M.metal];
for(let i=0;i<5;i++) makeBlock(12,0.5+i,-10,M.metal,1.2,1,1.2);
for(let i=0;i<25;i++){
  const s=0.4+Math.random()*0.8;
  makeBlock(-20+Math.random()*40,s/2,-3+Math.random()*-20,bmats[i%bmats.length],s,s,s);
}
makeSword(-3,1.5,2,0xc0c0c0,0x8b0000);
makeSword(3,1.5,2,0x4169e1,0x000088);
makeSword(0,1.5,-3,0x50c878,0x006400);

// Bunkers + environment
function makeBunker(x,z){
  box(6,1.5,1,M.concrete,x,0.75,z);
  box(1,1.5,3,M.concrete,x-2.5,0.75,z+1);
  box(1,1.5,3,M.concrete,x+2.5,0.75,z+1);
}
makeBunker(-8,-6); makeBunker(8,-6); makeBunker(0,-14);

// Barrels
[[6,0,-5,0x388e3c],[7,0,-5,0x388e3c],[6,0,-6,0xd32f2f],
 [-6,0,-5,0x388e3c],[-7,0,-5,0x388e3c],[-6,0,-6,0xd32f2f]].forEach(([x,,z,c])=>{
  cyl(0.34,0.37,0.9,16,new THREE.MeshStandardMaterial({color:c,roughness:0.6,metalness:0.4}),x,0.45,z);
});

// Trees
function makeTree(x,z){
  const h=4+Math.random()*3;
  cyl(0.18,0.28,h,8,new THREE.MeshStandardMaterial({color:0x4e342e,roughness:1}),x,h/2,z);
  sph(1.2+Math.random()*0.7,8,new THREE.MeshStandardMaterial({color:0x2e7d32,roughness:0.9}),x,h+1,z);
}
for(let i=0;i<28;i++){const a=Math.random()*Math.PI*2,r=28+Math.random()*20;makeTree(Math.cos(a)*r,Math.sin(a)*r);}

// Lamps
function makeLamp(x,z){
  cyl(0.05,0.08,4.5,8,M.metal,x,2.25,z);
  const pt=new THREE.PointLight(0xfff8e1,1.4,14); pt.position.set(x,4.5,z); scene.add(pt);
  const g=new THREE.Mesh(new THREE.SphereGeometry(0.18,8,8),new THREE.MeshBasicMaterial({color:0xfff9c4}));
  g.position.set(x,4.5,z); scene.add(g);
}
[[-8,0],[8,0],[0,-10],[0,12],[-15,6],[15,6]].forEach(([x,z])=>makeLamp(x,z));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HAND MODEL BUILDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildHandModel(side='right', skinColor=0xffcc99){
  const g = new THREE.Group();
  const smat = new THREE.MeshStandardMaterial({color:skinColor,roughness:0.8});
  const nmat = new THREE.MeshStandardMaterial({color:0xf0bea0,roughness:0.7});
  const flip = side==='left'?-1:1;

  // Palm
  const palm=new THREE.Mesh(new THREE.BoxGeometry(0.085,0.025,0.1),smat.clone());
  palm.position.set(0,0,0); g.add(palm);

  // Fingers
  const fingerDefs=[
    {ox:flip*-0.036,oz:-0.045,segs:3,lens:[0.04,0.03,0.025],thick:0.016},
    {ox:flip*-0.012,oz:-0.052,segs:3,lens:[0.045,0.033,0.027],thick:0.017},
    {ox:flip*0.012,oz:-0.05, segs:3,lens:[0.042,0.031,0.026],thick:0.016},
    {ox:flip*0.036,oz:-0.044,segs:3,lens:[0.036,0.027,0.022],thick:0.015},
  ];
  fingerDefs.forEach(({ox,oz,lens,thick})=>{
    let pz=oz;
    lens.forEach((len,si)=>{
      const seg=new THREE.Mesh(new THREE.BoxGeometry(thick,thick,len),smat.clone());
      seg.position.set(ox,0,pz-len/2);
      g.add(seg);
      if(si<lens.length-1){
        const jt=new THREE.Mesh(new THREE.SphereGeometry(thick*0.55,6,6),smat.clone());
        jt.position.set(ox,0,pz-len); g.add(jt);
      } else {
        // Fingernail
        const nail=new THREE.Mesh(new THREE.BoxGeometry(thick*0.7,0.004,len*0.6),nmat.clone());
        nail.position.set(ox,thick*0.52,pz-len*0.7); g.add(nail);
      }
      pz-=len;
    });
  });

  // Thumb
  const thumbSegs=[{len:0.035,thick:0.02},{len:0.028,thick:0.018}];
  let tx=flip*0.052, ty=0.006, tz=-0.015;
  thumbSegs.forEach(({len,thick},si)=>{
    const seg=new THREE.Mesh(new THREE.BoxGeometry(thick,thick,len),smat.clone());
    const angle=flip*(si===0?0.6:0.4);
    seg.position.set(tx,ty,tz-len/2); seg.rotation.y=angle; g.add(seg);
    tz-=len*Math.cos(Math.abs(angle)); tx+=len*Math.sin(Math.abs(angle))*flip;
    if(si===thumbSegs.length-1){
      const nail=new THREE.Mesh(new THREE.BoxGeometry(thick*0.7,0.004,len*0.6),nmat.clone());
      nail.position.set(tx-flip*0.01,ty+thick*0.52,tz+len*0.3); g.add(nail);
    }
  });

  // Wrist
  const wrist=new THREE.Mesh(new THREE.CylinderGeometry(0.032,0.028,0.06,10),smat.clone());
  wrist.rotation.x=Math.PI/2; wrist.position.set(0,0,0.045); g.add(wrist);

  // Orient: fingers point forward (-Z), back of hand up (+Y)
  g.rotation.x = -Math.PI/2;

  return g;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GUN BUILDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const WEAPONS = [
  {name:'PISTOL',  ammo:12,maxAmmo:12,reserve:60, damage:30,fireRate:0.25,spread:0.018,auto:false},
  {name:'RIFLE',   ammo:30,maxAmmo:30,reserve:150,damage:18,fireRate:0.09,spread:0.009,auto:true },
  {name:'SHOTGUN', ammo:8, maxAmmo:8, reserve:40, damage:22,fireRate:0.75,spread:0.09, auto:false,pellets:6},
];
let weaponIndex=0;
let cw={...WEAPONS[0]};

function buildGunModel(type){
  const g=new THREE.Group();
  const bm=new THREE.MeshStandardMaterial({color:[0x212121,0x1a237e,0x3e2723][type],roughness:0.4,metalness:0.8});
  const hm=new THREE.MeshStandardMaterial({color:0x3e2723,roughness:0.85});
  const mm=new THREE.MeshStandardMaterial({color:0x37474f,roughness:0.3,metalness:0.9});

  if(type===0){ // Pistol
    g.add(obj(new THREE.BoxGeometry(0.05,0.085,0.16),bm,[0,0,0]));
    g.add(obj(new THREE.BoxGeometry(0.04,0.11,0.065),hm,[0,-0.1,-0.02],[0.2,0,0]));
    g.add(obj(new THREE.CylinderGeometry(0.012,0.012,0.1,8),mm,[0,0.02,-0.13],[Math.PI/2,0,0]));
    g.add(obj(new THREE.BoxGeometry(0.04,0.025,0.16),mm,[0,0.056,0]));
  } else if(type===1){ // Rifle
    g.add(obj(new THREE.BoxGeometry(0.062,0.086,0.5),bm,[0,0,0]));
    g.add(obj(new THREE.BoxGeometry(0.052,0.12,0.072),hm,[0,-0.105,0.05],[0.3,0,0]));
    g.add(obj(new THREE.CylinderGeometry(0.015,0.015,0.3,8),mm,[0,0.03,-0.24],[Math.PI/2,0,0]));
    g.add(obj(new THREE.BoxGeometry(0.038,0.095,0.062),hm,[0,-0.098,0.11]));
    g.add(obj(new THREE.BoxGeometry(0.052,0.062,0.19),bm,[0,-0.01,0.29]));
    g.add(obj(new THREE.CylinderGeometry(0.02,0.02,0.13,8),mm,[0,0.072,-0.01],[Math.PI/2,0,0]));
    g.add(obj(new THREE.BoxGeometry(0.022,0.052,0.11),mm,[0,-0.068,-0.17]));
  } else { // Shotgun
    g.add(obj(new THREE.BoxGeometry(0.072,0.072,0.56),bm,[0,0,0]));
    g.add(obj(new THREE.BoxGeometry(0.052,0.13,0.078),hm,[0,-0.108,0.08],[0.2,0,0]));
    g.add(obj(new THREE.CylinderGeometry(0.021,0.021,0.4,8),mm,[0.032,0.02,-0.19],[Math.PI/2,0,0]));
    g.add(obj(new THREE.CylinderGeometry(0.021,0.021,0.4,8),mm,[-0.032,0.02,-0.19],[Math.PI/2,0,0]));
    g.add(obj(new THREE.BoxGeometry(0.062,0.072,0.21),hm,[0,0,0.33]));
  }

  // Muzzle flash
  const fl=new THREE.Mesh(new THREE.SphereGeometry(0.055,6,6),
    new THREE.MeshBasicMaterial({color:0xffff00,transparent:true,opacity:0}));
  fl.name='flash'; fl.position.z=-0.32; g.add(fl);
  const pl=new THREE.PointLight(0xffaa00,0,3); pl.name='mlight'; g.add(pl);

  return g;
}

function obj(geo,mat,pos=[0,0,0],rot=[0,0,0]){
  const m=new THREE.Mesh(geo,mat);
  m.position.set(...pos); m.rotation.set(...rot);
  m.castShadow=true; return m;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AMMO MAGAZINE MODEL (for free hand)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildMagModel(){
  const g=new THREE.Group();
  const mat=new THREE.MeshStandardMaterial({color:0x1a237e,roughness:0.5,metalness:0.6});
  const body=new THREE.Mesh(new THREE.BoxGeometry(0.036,0.09,0.058),mat);
  body.position.y=0.02; g.add(body);
  const bot=new THREE.Mesh(new THREE.CylinderGeometry(0.018,0.022,0.015,8),mat);
  bot.position.y=-0.028; g.add(bot);
  const bullet=new THREE.Mesh(new THREE.CylinderGeometry(0.006,0.006,0.018,6),
    new THREE.MeshStandardMaterial({color:0xffd700,metalness:0.9,roughness:0.1}));
  bullet.position.set(0,0.072,0); g.add(bullet);
  g.rotation.x=-Math.PI/2;
  return g;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VR CONTROLLER SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const ctrlFactory = new XRControllerModelFactory();
const vrControllers=[]; // [0]=left, [1]=right
const vrGrips=[];
const ctrlPrevPos=[new THREE.Vector3(),new THREE.Vector3()];
const ctrlVel=[new THREE.Vector3(),new THREE.Vector3()];
let grabbedObject=null; // only free hand can grab
let heldByFreeHand=false;
let reloading=false, reloadTimer=0;
let lastShot=0;

// Attach hands/gun after game starts
let gunGroup=null;    // attached to gun controller
let handGroup=null;   // attached to free controller
let magGroup=null;    // magazine on free hand
let gunModelGroup=null;
let needsHandRefresh=false;

function setupVRHands(){
  // Gun hand
  gunGroup=new THREE.Group();
  gunGroup.position.set(0,-0.01,-0.04);
  if(dominantHand==='right'){
    gunGroup.rotation.set(-Math.PI*0.05,0,0);
  } else {
    gunGroup.rotation.set(-Math.PI*0.05,Math.PI,0);
  }
  gunModelGroup=buildGunModel(weaponIndex);
  gunGroup.add(gunModelGroup);
  vrControllers[gunHandIndex].add(gunGroup);

  // Free hand = hand model
  handGroup=new THREE.Group();
  handGroup.position.set(0,-0.01,-0.04);
  const handModel=buildHandModel(dominantHand==='right'?'left':'right');
  handGroup.add(handModel);
  // Magazine on free hand palm
  magGroup=buildMagModel();
  magGroup.position.set(dominantHand==='right'?0.02:-0.02,-0.03,0);
  handGroup.add(magGroup);
  vrControllers[freeHandIndex].add(handGroup);

  // Ray on free hand for grab
  const ray=new THREE.Line(
    new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,-1)]),
    new THREE.LineBasicMaterial({color:0x00e5ff,transparent:true,opacity:0.4})
  );
  ray.scale.z=0.5; // very short = small grab range
  ray.name='ray';
  vrControllers[freeHandIndex].add(ray);
}

for(let i=0;i<2;i++){
  const ctrl=renderer.xr.getController(i);
  ctrl.userData.index=i;
  playerRig.add(ctrl);
  const grip=renderer.xr.getControllerGrip(i);
  grip.add(ctrlFactory.createControllerModel(grip));
  playerRig.add(grip);
  vrControllers.push(ctrl);
  vrGrips.push(grip);
}

// GRIP = grab (free hand only)
vrControllers[0].addEventListener('squeezestart',()=>{ if(freeHandIndex===0) tryGrab(0); });
vrControllers[0].addEventListener('squeezeend',  ()=>{ if(freeHandIndex===0) releaseGrab(0); });
vrControllers[1].addEventListener('squeezestart',()=>{ if(freeHandIndex===1) tryGrab(1); });
vrControllers[1].addEventListener('squeezeend',  ()=>{ if(freeHandIndex===1) releaseGrab(1); });

// TRIGGER = shoot (gun hand only) or reload check
vrControllers[0].addEventListener('selectstart',()=>{ if(gunHandIndex===0) vrShoot(); else checkVRReload(); });
vrControllers[1].addEventListener('selectstart',()=>{ if(gunHandIndex===1) vrShoot(); else checkVRReload(); });

function tryGrab(ctrlIdx){
  // Only free hand
  if(ctrlIdx!==freeHandIndex) return;
  const ctrl=vrControllers[ctrlIdx];
  const ctrlPos=new THREE.Vector3().setFromMatrixPosition(ctrl.matrixWorld);

  let closest=null, closestDist=GRAB_RADIUS;
  for(const p of physObjects){
    if(p.heldBy!==null) continue;
    const dist=ctrlPos.distanceTo(p.mesh.position);
    if(dist<closestDist){ closestDist=dist; closest=p; }
  }
  if(closest){
    closest.heldBy=ctrlIdx;
    grabbedObject=closest;
    closest.vel.set(0,0,0); closest.avel.set(0,0,0);
    ctrl.attach(closest.mesh);
    // Hide mag when grabbing
    if(magGroup) magGroup.visible=false;
  }
}

function releaseGrab(ctrlIdx){
  if(!grabbedObject||grabbedObject.heldBy!==ctrlIdx) return;
  const go=grabbedObject;
  scene.attach(go.mesh);
  const throwVel=ctrlVel[ctrlIdx].clone().multiplyScalar(3.5);
  go.vel.copy(throwVel);
  go.avel.set((Math.random()-0.5)*6,(Math.random()-0.5)*6,(Math.random()-0.5)*6);
  go.heldBy=null;
  grabbedObject=null;
  if(magGroup) magGroup.visible=true;
}

// Thumbstick weapon switching (gun hand)
let thumbWasNeutral=[true,true];
function handleThumbstick(src, i){
  if(i!==gunHandIndex||!src.gamepad) return;
  const ay=src.gamepad.axes[3];
  if(ay===undefined) return;
  if(Math.abs(ay)>0.6 && thumbWasNeutral[i]){
    thumbWasNeutral[i]=false;
    weaponIndex=(weaponIndex+(ay<0?-1:1)+WEAPONS.length)%WEAPONS.length;
    cw={...WEAPONS[weaponIndex]};
    // Rebuild gun model
    if(gunModelGroup&&gunGroup){ gunGroup.remove(gunModelGroup); gunModelGroup=buildGunModel(weaponIndex); gunGroup.add(gunModelGroup); }
    updateAmmoHUD();
    document.getElementById('eq-weapon').textContent=cw.name;
  }
  if(Math.abs(ay)<0.3) thumbWasNeutral[i]=true;
}

// VR Reload: bring free hand close to gun hand
function checkVRReload(){
  if(reloading||cw.ammo===cw.maxAmmo) return;
  const gPos=new THREE.Vector3().setFromMatrixPosition(vrControllers[gunHandIndex].matrixWorld);
  const fPos=new THREE.Vector3().setFromMatrixPosition(vrControllers[freeHandIndex].matrixWorld);
  if(gPos.distanceTo(fPos)<0.25) startReload();
}

function vrShoot(){
  const now=performance.now()/1000;
  if(reloading||now-lastShot<cw.fireRate) return;
  if(cw.ammo<=0){ startReload(); return; }
  lastShot=now; cw.ammo--; updateAmmoHUD();
  // Flash
  const fl=gunModelGroup?.getObjectByName?.('flash');
  const pl=gunModelGroup?.getObjectByName?.('mlight');
  if(fl){fl.material.opacity=1;setTimeout(()=>fl.material.opacity=0,55);}
  if(pl){pl.intensity=4;setTimeout(()=>pl.intensity=0,55);}
  // Haptic
  const src=renderer.xr.getSession()?.inputSources?.[gunHandIndex];
  src?.gamepad?.hapticActuators?.[0]?.pulse(0.5,60);

  const pellets=cw.pellets||1;
  for(let p=0;p<pellets;p++){
    const sp=cw.spread;
    const dir=new THREE.Vector3((Math.random()-0.5)*sp*2,(Math.random()-0.5)*sp*2,-1).normalize();
    dir.applyQuaternion(vrControllers[gunHandIndex].getWorldQuaternion(new THREE.Quaternion()));
    spawnBullet(new THREE.Vector3().setFromMatrixPosition(vrControllers[gunHandIndex].matrixWorld).addScaledVector(dir,0.2),dir,false);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DESKTOP GUN (camera-mounted)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const desktopGunGroup=new THREE.Group();
camera.add(desktopGunGroup);
desktopGunGroup.position.set(0.22,-0.17,-0.42);

function refreshDesktopGun(){
  desktopGunGroup.clear();
  const gm=buildGunModel(weaponIndex);
  desktopGunGroup.add(gm);
}
refreshDesktopGun();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BULLETS + PARTICLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const bulletGeo=new THREE.SphereGeometry(0.033,5,5);
const bullets=[];
const particles=[];

function spawnBullet(pos,dir,isNPC){
  const b=new THREE.Mesh(bulletGeo,new THREE.MeshBasicMaterial({color:isNPC?0xff4444:0xffff00}));
  b.position.copy(pos);
  b.userData={vel:dir.clone().multiplyScalar(isNPC?26:82),life:2.5,alive:true,isNPC};
  scene.add(b); bullets.push(b);
}

function spawnParticles(pos,col=0xff6600,n=8){
  for(let i=0;i<n;i++){
    const p=new THREE.Mesh(new THREE.SphereGeometry(0.04+Math.random()*0.04,4,4),
      new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:1}));
    p.position.copy(pos);
    p.userData={vel:new THREE.Vector3((Math.random()-0.5)*10,Math.random()*8+3,(Math.random()-0.5)*10),life:0.5+Math.random()*0.4};
    scene.add(p); particles.push(p);
  }
}

function showHit(){
  const hm=document.getElementById('hitmarker');
  hm.classList.add('show'); setTimeout(()=>hm.classList.remove('show'),110);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RELOAD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startReload(){
  if(reloading||cw.reserve<=0) return;
  reloading=true;
  const rt=cw.name==='PISTOL'?1.1:cw.name==='RIFLE'?1.8:2.0;
  document.getElementById('ammo-display').textContent='RELOADING...';
  document.getElementById('reload-bar').style.display='block';
  const rf=document.getElementById('reload-fill');
  rf.style.transition='none'; rf.style.width='0%';
  setTimeout(()=>{rf.style.transition=`width ${rt}s linear`;rf.style.width='100%';},30);
  setTimeout(()=>{
    const need=cw.maxAmmo-cw.ammo,got=Math.min(need,cw.reserve);
    cw.ammo+=got; cw.reserve-=got; reloading=false;
    document.getElementById('reload-bar').style.display='none';
    rf.style.width='0%'; updateAmmoHUD();
  },rt*1000);
}
function updateAmmoHUD(){
  if(!reloading) document.getElementById('ammo-display').textContent=`${cw.ammo} / ${cw.reserve}`;
  document.getElementById('eq-weapon').textContent=WEAPONS[weaponIndex].name;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NPCs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const npcs=[];
let waveNum=1,waveKills=0,waveTarget=5;
const npcColors=[0xf44336,0x2196f3,0x4caf50,0xffeb3b,0x9c27b0,0xff9800];

class NPC{
  constructor(x,z,col,boss=false){
    this.alive=true; this.health=boss?500:100; this.maxHP=boss?500:100;
    this.boss=boss; this.color=col;
    this.g=new THREE.Group(); this.g.position.set(x,0,z); scene.add(this.g);
    const sc=boss?1.8:1;
    this.bm=new THREE.MeshStandardMaterial({color:col,roughness:0.7});
    this.body=new THREE.Mesh(new THREE.CylinderGeometry(0.27*sc,0.31*sc,1.15*sc,10),this.bm.clone());
    this.body.position.y=0.95*sc; this.body.castShadow=true; this.g.add(this.body);
    this.headM=new THREE.Mesh(new THREE.SphereGeometry(0.22*sc,12,12),
      new THREE.MeshStandardMaterial({color:boss?0xff6666:0xffcc99,roughness:0.7}));
    this.headM.position.y=1.65*sc; this.headM.castShadow=true; this.g.add(this.headM);
    const am=new THREE.MeshStandardMaterial({color:col,roughness:0.7});
    this.lA=new THREE.Mesh(new THREE.CylinderGeometry(0.085*sc,0.075*sc,0.78*sc,8),am.clone());
    this.lA.position.set(-0.36*sc,0.9*sc,0); this.lA.rotation.z=0.4; this.lA.castShadow=true; this.g.add(this.lA);
    this.rA=this.lA.clone(); this.rA.material=am.clone(); this.rA.position.x=0.36*sc; this.rA.rotation.z=-0.4; this.g.add(this.rA);
    this.lL=new THREE.Mesh(new THREE.CylinderGeometry(0.09*sc,0.08*sc,0.82*sc,8),am.clone());
    this.lL.position.set(-0.17*sc,0.41*sc,0); this.lL.castShadow=true; this.g.add(this.lL);
    this.rL=this.lL.clone(); this.rL.material=am.clone(); this.rL.position.x=0.17*sc; this.g.add(this.rL);
    // healthbar
    this.hbg=new THREE.Group(); this.hbg.position.y=(boss?3.8:2.3)*sc; this.g.add(this.hbg);
    const bw=boss?1.2:0.72;
    this.hbg.add(new THREE.Mesh(new THREE.PlaneGeometry(bw,0.11),new THREE.MeshBasicMaterial({color:0x222222})));
    this.hbar=new THREE.Mesh(new THREE.PlaneGeometry(bw-0.04,0.08),new THREE.MeshBasicMaterial({color:0x00e676}));
    this.hbar.position.z=0.01; this.hbg.add(this.hbar);
    this.t=Math.random()*100; this.dir=Math.random()*Math.PI*2; this.tdir=this.dir;
    this.shootTimer=Math.random()*3;
    npcs.push(this);
  }
  takeDamage(amt){
    if(!this.alive) return;
    this.health-=amt; const p=Math.max(0,this.health)/this.maxHP;
    const bw=this.boss?1.16:0.68;
    this.hbar.scale.x=p; this.hbar.position.x=-bw/2*(1-p);
    this.hbar.material.color.setHex(p>0.5?0x00e676:p>0.25?0xffeb3b:0xff1744);
    if(this.health<=0) this.die();
    else{ this.body.material.emissive.setHex(0xff0000); this.body.material.emissiveIntensity=0.6;
      setTimeout(()=>{this.body.material.emissive.setHex(0);this.body.material.emissiveIntensity=0;},140); }
  }
  die(){
    this.alive=false; waveKills++;
    const sc=document.getElementById('scoreVal');
    document.getElementById('kills').textContent=parseInt(document.getElementById('kills').textContent)+1;
    sc.textContent=parseInt(sc.textContent)+(this.boss?1000:100);
    this.g.rotation.x=Math.PI/2; this.hbg.visible=false;
    spawnParticles(this.g.position.clone(),this.color,this.boss?25:10);
    setTimeout(()=>{scene.remove(this.g);npcs.splice(npcs.indexOf(this),1);checkWave();},2500);
  }
  update(dt){
    if(!this.alive) return;
    this.t+=dt;
    this.lA.rotation.x=Math.sin(this.t*2.5)*0.4; this.rA.rotation.x=-Math.sin(this.t*2.5)*0.4;
    this.lL.rotation.x=Math.sin(this.t*3)*0.35; this.rL.rotation.x=-Math.sin(this.t*3)*0.35;
    this.g.position.y=Math.abs(Math.sin(this.t*4))*0.06;
    this.tdir+=(Math.random()-0.5)*0.05; this.dir+=(this.tdir-this.dir)*0.04;
    const sp=this.boss?2.2:1.6;
    let nx=this.g.position.x+Math.cos(this.dir)*sp*dt;
    let nz=this.g.position.z+Math.sin(this.dir)*sp*dt;
    // stone collision
    for(const st of stoneObjects){
      const dx=nx-st.mesh.position.x, dz=nz-st.mesh.position.z;
      const dist=Math.sqrt(dx*dx+dz*dz);
      if(dist<st.radius+0.35){ this.tdir+=Math.PI+(Math.random()-0.5); nx=this.g.position.x; nz=this.g.position.z; }
    }
    this.g.position.x=nx; this.g.position.z=nz;
    if(Math.abs(this.g.position.x)>48||Math.abs(this.g.position.z)>48) this.tdir+=Math.PI;
    this.g.rotation.y=this.dir+Math.PI/2;
    this.hbg.quaternion.copy(camera.quaternion);
    this.shootTimer-=dt;
    if(this.shootTimer<=0){
      this.shootTimer=(this.boss?1.5:3+Math.random()*2);
      this.npcShoot();
    }
    // Chase player
    const tp=playerRig.position.clone().sub(this.g.position);
    if(tp.length()<30) this.tdir=Math.atan2(tp.z,tp.x)-Math.PI/2;
  }
  npcShoot(){
    const orig=this.g.position.clone().add(new THREE.Vector3(0,1.4,0));
    const target=playerRig.position.clone().add(new THREE.Vector3(0,1.6,0));
    if(orig.distanceTo(target)>38) return;
    const dir=target.sub(orig).normalize().add(new THREE.Vector3((Math.random()-0.5)*0.12,(Math.random()-0.5)*0.06,(Math.random()-0.5)*0.12)).normalize();
    spawnBullet(orig,dir,true);
  }
}

function spawnNPC(boss=false){
  const a=Math.random()*Math.PI*2,r=20+Math.random()*18;
  new NPC(Math.cos(a)*r,Math.sin(a)*r,npcColors[Math.floor(Math.random()*npcColors.length)],boss);
}
function checkWave(){
  if(npcs.filter(n=>n.alive).length===0&&waveKills>=waveTarget){
    waveNum++; waveKills=0; waveTarget=Math.floor(waveNum*4+3);
    const b=document.getElementById('wave-banner');
    b.textContent=`âš”ï¸ WAVE ${waveNum}!`; b.classList.add('show');
    document.getElementById('wave').textContent=waveNum;
    setTimeout(()=>b.classList.remove('show'),2500);
    setTimeout(()=>{
      const cnt=Math.min(3+waveNum,16);
      for(let i=0;i<cnt;i++) spawnNPC();
      if(waveNum%5===0) spawnNPC(true);
    },3000);
  }
}
for(let i=0;i<6;i++) spawnNPC();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RAYCASTER / HIT DETECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const sRay=new THREE.Raycaster();
function getHittables(){
  return[...npcs.filter(n=>n.alive).flatMap(n=>[n.body,n.headM]),
    ...targets.filter(t=>t.userData.alive),
    ...destructibles.map(d=>d.mesh).filter(m=>m.userData.alive),
    ...physObjects.map(p=>p.mesh),
    ground];
}

function processBullet(b,hits){
  if(!hits.length) return false;
  const h=hits[0]; const pos=h.point.clone();
  // NPC hit
  for(const n of npcs){
    if(!n.alive) continue;
    if(h.object===n.body||h.object===n.headM){
      if(b.userData.isNPC) return true;
      const dmg=(h.object===n.headM?2.5:1)*cw.damage;
      n.takeDamage(dmg); showHit();
      document.getElementById('scoreVal').textContent=parseInt(document.getElementById('scoreVal').textContent)+Math.floor(dmg);
      spawnParticles(pos,0xff3333); return true;
    }
  }
  // Target
  for(const t of targets){
    if(!t.userData.alive) continue;
    if(h.object.parent===t||h.object===t){
      t.userData.health--; showHit();
      if(t.userData.health<=0) destroyTarget(t);
      else spawnParticles(pos,0xff1744);
      return true;
    }
  }
  // Destructible
  for(const d of destructibles){
    if(h.object===d.mesh&&d.mesh.userData.alive){
      d.mesh.userData.alive=false; d.mesh.userData.falling=true;
      d.mesh.userData.vel.set((Math.random()-0.5)*4,Math.random()*5+2,(Math.random()-0.5)*4);
      d.mesh.userData.avel.set((Math.random()-0.5)*7,(Math.random()-0.5)*7,(Math.random()-0.5)*7);
      spawnParticles(pos,0xd84315); showHit(); return true;
    }
  }
  // Physics block
  for(const pk of physObjects){
    if(h.object===pk.mesh){
      pk.vel.addScaledVector(b.userData.vel.clone().normalize(),5); pk.vel.y+=2.5; pk.grounded=false;
      spawnParticles(pos,0x9e9e9e); showHit(); return true;
    }
  }
  // Player hit by NPC
  if(b.userData.isNPC){
    const ppos=playerRig.position.clone().add(new THREE.Vector3(0,1.6,0));
    if(pos.distanceTo(ppos)<0.6){
      const hpEl=document.getElementById('hp');
      const v=Math.max(0,parseInt(hpEl.textContent)-8);
      hpEl.textContent=v; hpEl.style.color=v<30?'#ff1744':'#fff';
    }
  }
  spawnParticles(pos,0x795548,4); return false;
}

function destroyTarget(t){
  t.userData.alive=false;
  document.getElementById('scoreVal').textContent=parseInt(document.getElementById('scoreVal').textContent)+50;
  spawnParticles(t.position.clone(),0xff1744);
  scene.remove(t); targets.splice(targets.indexOf(t),1);
  setTimeout(()=>{makeTarget(-14+Math.random()*28,1.6,-20-Math.random()*18,Math.random()>0.5);},3500);
}

function checkSwordHits(){
  for(const p of physObjects){
    if(p.type!=='sword') continue;
    const spd=p.vel.length();
    if(spd<2&&p.heldBy===null) continue;
    for(const n of npcs){
      if(!n.alive) continue;
      if(p.mesh.position.distanceTo(n.g.position)<1.3){
        n.takeDamage(p.heldBy!==null?18:30); showHit();
        spawnParticles(p.mesh.position.clone(),0xffd700,5);
      }
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DESKTOP INPUT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const keys={};
let recoilZ=0, lastDesktopShot=0, autoFire=null;
let desktopWeapon={...WEAPONS[0]};
let dWeapIdx=0;

window.addEventListener('keydown',e=>{
  keys[e.code]=true;
  if(e.code==='KeyR') startReload();
  if(e.code==='KeyF'){ if(document.pointerLockElement) document.exitPointerLock(); else renderer.domElement.requestPointerLock(); }
  if(e.code==='Digit1'){ dWeapIdx=0; cw={...WEAPONS[0]}; refreshDesktopGun(); updateAmmoHUD(); }
  if(e.code==='Digit2'){ dWeapIdx=1; cw={...WEAPONS[1]}; refreshDesktopGun(); updateAmmoHUD(); }
  if(e.code==='Digit3'){ dWeapIdx=2; cw={...WEAPONS[2]}; refreshDesktopGun(); updateAmmoHUD(); }
});
window.addEventListener('keyup',e=>keys[e.code]=false);

const yaw=new THREE.Euler(0,0,0,'YXZ'); let pitch=0;
window.addEventListener('mousemove',e=>{
  if(document.pointerLockElement!==renderer.domElement) return;
  yaw.y-=e.movementX*0.002; pitch=Math.max(-1.2,Math.min(1.2,pitch-e.movementY*0.002));
});
renderer.domElement.addEventListener('click',()=>{
  if(document.pointerLockElement!==renderer.domElement) renderer.domElement.requestPointerLock();
});
window.addEventListener('mousedown',e=>{
  if(e.button!==0||document.pointerLockElement!==renderer.domElement) return;
  desktopShoot();
  if(cw.auto) autoFire=setInterval(desktopShoot,cw.fireRate*1000);
});
window.addEventListener('mouseup',()=>{clearInterval(autoFire);autoFire=null;});

function desktopShoot(){
  const now=performance.now()/1000;
  if(reloading||now-lastDesktopShot<cw.fireRate) return;
  if(cw.ammo<=0){startReload();return;}
  lastDesktopShot=now; cw.ammo--; updateAmmoHUD(); recoilZ=0.04;
  const fl=desktopGunGroup.getObjectByName('flash');
  const pl=desktopGunGroup.getObjectByName('mlight');
  if(fl){fl.material.opacity=1;setTimeout(()=>fl.material.opacity=0,55);}
  if(pl){pl.intensity=4;setTimeout(()=>pl.intensity=0,55);}
  const pellets=cw.pellets||1;
  for(let p=0;p<pellets;p++){
    const dir=new THREE.Vector3((Math.random()-0.5)*cw.spread*2,(Math.random()-0.5)*cw.spread*2,-1).normalize();
    dir.applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
    const pos=new THREE.Vector3(); camera.getWorldPosition(pos); pos.addScaledVector(dir,0.5);
    spawnBullet(pos,dir,false);
  }
}

const pVel=new THREE.Vector3(); let grounded=false;
function updateDesktopPlayer(dt){
  const fwd=new THREE.Vector3(-Math.sin(yaw.y),0,-Math.cos(yaw.y));
  const rgt=new THREE.Vector3(Math.cos(yaw.y),0,-Math.sin(yaw.y));
  const sp=keys['ShiftLeft']?1.8:1;
  if(keys['KeyW'])pVel.addScaledVector(fwd,5.5*sp*dt*3);
  if(keys['KeyS'])pVel.addScaledVector(fwd,-5.5*dt*3);
  if(keys['KeyA'])pVel.addScaledVector(rgt,-5.5*sp*dt*3);
  if(keys['KeyD'])pVel.addScaledVector(rgt,5.5*sp*dt*3);
  if(keys['Space']&&grounded){pVel.y=8;grounded=false;}
  pVel.y-=22*dt; pVel.x*=0.82; pVel.z*=0.82;

  // Stone collision for player
  let np=playerRig.position.clone().addScaledVector(pVel,dt);
  for(const st of stoneObjects){
    const dx=np.x-st.mesh.position.x, dz=np.z-st.mesh.position.z;
    const dist=Math.sqrt(dx*dx+dz*dz);
    if(dist<st.radius+0.4){
      const push=new THREE.Vector3(dx,0,dz).normalize().multiplyScalar(st.radius+0.4-dist+0.01);
      np.x+=push.x; np.z+=push.z; pVel.x*=0.2; pVel.z*=0.2;
    }
  }
  playerRig.position.copy(np);
  if(playerRig.position.y<0){playerRig.position.y=0;pVel.y=0;grounded=true;}
  camera.rotation.set(pitch,0,0); playerRig.rotation.y=yaw.y;
  if(recoilZ>0){desktopGunGroup.position.z=-0.42+recoilZ*0.5;recoilZ*=0.72;if(recoilZ<0.001)recoilZ=0;}
  else desktopGunGroup.position.z=-0.42;
  const tt=performance.now()*0.001;
  const mv=keys['KeyW']||keys['KeyA']||keys['KeyS']||keys['KeyD'];
  desktopGunGroup.position.y=-0.17+(mv?Math.sin(tt*8)*0.007:Math.sin(tt*1.5)*0.003);
  desktopGunGroup.position.x=0.22+(mv?Math.sin(tt*4)*0.005:0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENTER VR / DESKTOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.chooseHand=function(hand){
  dominantHand=hand;
  gunHandIndex  = hand==='right'?1:0;
  freeHandIndex = hand==='right'?0:1;
  document.getElementById('handedness-display').innerHTML=
    `ğŸ– <b>${hand.toUpperCase()} HANDED</b> â€” Gun: ${hand} hand, Free: ${hand==='right'?'left':'right'} hand`;
  document.getElementById('handedness-screen').style.display='none';
  document.getElementById('mode-screen').style.display='flex';
  checkVRStatus();
};

async function checkVRStatus(){
  const st=document.getElementById('vr-check-status');
  if(!navigator.xr){st.textContent='âŒ WebXR not available â€” use Desktop Mode';return;}
  try{
    const ok=await navigator.xr.isSessionSupported('immersive-vr');
    st.textContent=ok?'âœ… VR headset detected!':'âš ï¸ No VR headset â€” connect one or use Desktop Mode';
    if(!ok) document.getElementById('vr-mode-btn').style.opacity='0.5';
  }catch(e){st.textContent='âš ï¸ VR check blocked â€” try Oculus/Firefox browser';}
}

window.enterVR=async function(){
  try{
    if(!navigator.xr) throw new Error('WebXR not available');
    const ok=await navigator.xr.isSessionSupported('immersive-vr');
    if(!ok) throw new Error('VR not supported on this device');
    const session=await navigator.xr.requestSession('immersive-vr',{
      requiredFeatures:['local-floor'],
      optionalFeatures:['bounded-floor','hand-tracking']
    });
    await renderer.xr.setSession(session);
    isVR=true;
    document.getElementById('mode-screen').style.display='none';
    document.getElementById('hud').style.display='block';
    document.getElementById('vr-hint').style.display='block';
    setTimeout(()=>document.getElementById('vr-hint').style.display='none',8000);
    desktopGunGroup.visible=false;
    setupVRHands();
    cw={...WEAPONS[weaponIndex]};
    updateAmmoHUD();
    gameStarted=true;
  }catch(err){
    alert('Could not enter VR:\n'+err.message+'\n\nUse Desktop Mode instead.');
  }
};
window.enterVR=window.enterVR; // expose

window.enterDesktop=function(){
  document.getElementById('mode-screen').style.display='none';
  document.getElementById('hud').style.display='block';
  renderer.domElement.requestPointerLock();
  cw={...WEAPONS[0]}; updateAmmoHUD();
  gameStarted=true;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const clock=new THREE.Clock();
let snapCooldown=0;

renderer.setAnimationLoop(()=>{
  const dt=Math.min(clock.getDelta(),0.05);
  const t=clock.getElapsedTime();

  if(!gameStarted) return;

  // Desktop movement
  if(!isVR && document.getElementById('hud').style.display==='block') updateDesktopPlayer(dt);

  // VR controller velocity tracking
  vrControllers.forEach((ctrl,i)=>{
    const cur=new THREE.Vector3().setFromMatrixPosition(ctrl.matrixWorld);
    if(dt>0) ctrlVel[i].subVectors(cur,ctrlPrevPos[i]).divideScalar(dt);
    ctrlPrevPos[i].copy(cur);
  });

  // VR locomotion + weapon switch + snap turn
  if(isVR){
    const session=renderer.xr.getSession();
    if(session){
      snapCooldown=Math.max(0,snapCooldown-dt);
      for(const src of session.inputSources){
        const gp=src.gamepad; if(!gp) continue;
        const hi=src.handedness==='right'?1:0;
        const ax=gp.axes;

        handleThumbstick(src,hi);

        if(src.handedness==='left'){
          // Left stick = move
          if(ax.length>=4){
            const fwd=new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            fwd.y=0; fwd.normalize();
            const rgt=new THREE.Vector3(1,0,0).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            rgt.y=0; rgt.normalize();
            playerRig.position.addScaledVector(fwd,-ax[3]*3*dt);
            playerRig.position.addScaledVector(rgt, ax[2]*3*dt);
          }
        }
        if(src.handedness==='right'){
          // Right stick X = snap turn
          if(ax.length>=4&&snapCooldown<=0&&Math.abs(ax[2])>0.7){
            playerRig.rotation.y-=Math.sign(ax[2])*Math.PI/4;
            snapCooldown=0.4;
          }
        }

        // Stone collision in VR
        for(const st of stoneObjects){
          const dx=playerRig.position.x-st.mesh.position.x;
          const dz=playerRig.position.z-st.mesh.position.z;
          const dist=Math.sqrt(dx*dx+dz*dz);
          if(dist<st.radius+0.4&&dist>0){
            const push=new THREE.Vector3(dx,0,dz).normalize();
            playerRig.position.x+=push.x*(st.radius+0.4-dist+0.01);
            playerRig.position.z+=push.z*(st.radius+0.4-dist+0.01);
          }
        }
      }
    }
  }

  // Bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    if(!b.userData.alive){scene.remove(b);bullets.splice(i,1);continue;}
    b.userData.life-=dt; if(b.userData.life<=0){b.userData.alive=false;continue;}
    b.position.addScaledVector(b.userData.vel,dt);
    b.userData.vel.y-=9.8*dt*0.2;
    sRay.set(b.position,b.userData.vel.clone().normalize());
    sRay.far=b.userData.vel.length()*dt*2.5;
    if(processBullet(b,sRay.intersectObjects(getHittables(),true))) b.userData.alive=false;
  }

  // Particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i]; p.userData.life-=dt;
    if(p.userData.life<=0){scene.remove(p);particles.splice(i,1);continue;}
    p.userData.vel.y-=22*dt; p.position.addScaledVector(p.userData.vel,dt);
    p.material.opacity=Math.max(0,p.userData.life/0.8);
    if(!p.material.transparent) p.material.transparent=true;
  }

  // Physics objects
  for(const p of physObjects){
    if(p.heldBy!==null) continue;
    if(p.grounded&&p.vel.lengthSq()<0.01) continue;
    p.vel.y-=16*dt;
    p.mesh.position.addScaledVector(p.vel,dt);
    p.mesh.rotation.x+=p.avel.x*dt; p.mesh.rotation.y+=p.avel.y*dt; p.mesh.rotation.z+=p.avel.z*dt;
    p.vel.multiplyScalar(0.98); p.avel.multiplyScalar(0.96);
    if(p.mesh.position.y<0.25){
      p.mesh.position.y=0.25; p.vel.y=Math.abs(p.vel.y)*0.3;
      p.vel.x*=0.75; p.vel.z*=0.75; p.avel.multiplyScalar(0.75);
      if(Math.abs(p.vel.y)<0.05) p.grounded=true;
    }
    // Stone collision for objects
    for(const st of stoneObjects){
      const dx=p.mesh.position.x-st.mesh.position.x, dz=p.mesh.position.z-st.mesh.position.z;
      const dist=Math.sqrt(dx*dx+dz*dz);
      if(dist<st.radius+0.3&&dist>0){
        const n2=new THREE.Vector3(dx,0,dz).normalize();
        p.mesh.position.x+=n2.x*(st.radius+0.3-dist);
        p.mesh.position.z+=n2.z*(st.radius+0.3-dist);
        p.vel.reflect(n2); p.vel.multiplyScalar(0.4);
      }
    }
  }

  // Destructible bricks
  destructibles.forEach(({mesh:m})=>{
    if(!m.userData.falling) return;
    m.userData.vel.y-=16*dt; m.position.addScaledVector(m.userData.vel,dt);
    m.rotation.x+=m.userData.avel.x*dt; m.rotation.y+=m.userData.avel.y*dt; m.rotation.z+=m.userData.avel.z*dt;
    m.userData.vel.multiplyScalar(0.98); m.userData.avel.multiplyScalar(0.96);
    if(m.position.y<0.28){m.position.y=0.28;m.userData.vel.y=Math.abs(m.userData.vel.y)*0.28;m.userData.vel.x*=0.7;m.userData.vel.z*=0.7;m.userData.avel.multiplyScalar(0.75);}
  });

  // NPCs
  npcs.forEach(n=>n.update(dt));
  checkSwordHits();

  // Targets
  targets.forEach(tg=>{
    if(!tg.userData.alive) return;
    if(tg.userData.spin) tg.rotation.y+=tg.userData.spinSpeed*dt;
    if(tg.userData.moving) tg.position.x=tg.userData.baseX+Math.sin(t*tg.userData.speed+tg.userData.phase)*tg.userData.range;
  });

  renderer.render(scene,camera);
});

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
