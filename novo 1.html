<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>VR Ultimate Sandbox - Full Playground & Combat</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info { 
            position: absolute; top: 10px; left: 10px; color: white; 
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; 
            z-index: 100; font-family: sans-serif; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">
        <b>CONTROLS:</b><br>
        Left Stick: Move | Right Stick: Turn<br>
        Side Grip: Pick up/Throw | Trigger: Fire Gun<br>
        Chest: Grab Ammo
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // --- 1. CORE ENGINE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 0, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        // Camera Group for VR Locomotion
        const cameraGroup = new THREE.Group();
        cameraGroup.add(camera);
        scene.add(cameraGroup);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);

        // --- 2. LIGHTING ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const sun = new THREE.DirectionalLight(0xffffff, 1.0);
        sun.position.set(20, 40, 20);
        sun.castShadow = true;
        sun.shadow.camera.left = -40; sun.shadow.camera.right = 40;
        sun.shadow.camera.top = 40; sun.shadow.camera.bottom = -40;
        sun.shadow.mapSize.set(2048, 2048);
        scene.add(sun);
        scene.add(new THREE.HemisphereLight(0x87ceeb, 0x4a7c59, 0.4));

        // --- 3. GROUND ---
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x55aa55, roughness: 0.8 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- 4. ADVANCED PHYSICS SYSTEM (THROWING) ---
        const physicsObjects = [];
        class PhysicsObject {
            constructor(mesh, type = 'prop') {
                this.mesh = mesh;
                this.type = type;
                this.velocity = new THREE.Vector3();
                this.isGrabbed = false;
                this.ammoCount = 0;
                this.lastPos = new THREE.Vector3();
                this.isDead = false;
                physicsObjects.push(this);
            }
            update(dt) {
                if (this.isGrabbed) {
                    // Calculate throwing velocity based on hand movement
                    const currentPos = new THREE.Vector3().setFromMatrixPosition(this.mesh.matrixWorld);
                    this.velocity.subVectors(currentPos, this.lastPos).divideScalar(dt);
                    this.lastPos.copy(currentPos);
                    return;
                }
                // Gravity & Friction
                this.velocity.y -= 9.8 * dt;
                this.mesh.position.addScaledVector(this.velocity, dt);
                if (this.mesh.position.y < 0.1) {
                    this.mesh.position.y = 0.1;
                    this.velocity.set(0,0,0);
                }
                this.velocity.multiplyScalar(0.99); // Air resistance
            }
            grab() { this.isGrabbed = true; this.velocity.set(0,0,0); }
            release(handVel) { 
                this.isGrabbed = false; 
                this.velocity.copy(handVel); 
            }
        }

        // --- 5. PLAYGROUND EQUIPMENT (RE-ADDED ALL) ---
        
        // SLIDE
        const slide = new THREE.Group();
        const sPlat = new THREE.Mesh(new THREE.BoxGeometry(3, 0.3, 3), new THREE.MeshStandardMaterial({ color: 0xff6600 }));
        sPlat.position.y = 3;
        const sRamp = new THREE.Mesh(new THREE.BoxGeometry(3, 0.3, 6), new THREE.MeshStandardMaterial({ color: 0xffcc00 }));
        sRamp.position.set(0, 1.5, 3.5); sRamp.rotation.x = -0.55;
        slide.add(sPlat, sRamp);
        for(let i=0; i<4; i++){
            const p = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,3), new THREE.MeshStandardMaterial({color: 0x8b4513}));
            p.position.set(i<2?-1.3:1.3, 1.5, i%2==0?-1.3:1.3); slide.add(p);
        }
        slide.position.set(-15, 0, -15); scene.add(slide);

        // SWING SET
        const swings = new THREE.Group();
        const swTop = new THREE.Mesh(new THREE.BoxGeometry(8,0.2,0.2), new THREE.MeshStandardMaterial({color: 0x8b4513}));
        swTop.position.y = 4; swings.add(swTop);
        for(let i=0; i<3; i++){
            const seat = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.1,0.4), new THREE.MeshStandardMaterial({color:0xff0000}));
            seat.position.set(-2.5+i*2.5, 1.2, 0); swings.add(seat);
        }
        swings.position.set(15, 0, -15); scene.add(swings);

        // INTERACTIVE MERRY-GO-ROUND
        const mgr = new THREE.Group();
        const mgBase = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0xff00ff }));
        mgBase.position.y = 0.1; mgr.add(mgBase);
        const mgHandles = [];
        for (let i = 0; i < 8; i++) {
            const h = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.2), new THREE.MeshStandardMaterial({ color: 0xffff00 }));
            const ang = (i / 8) * Math.PI * 2;
            h.position.set(Math.cos(ang)*2.5, 0.6, Math.sin(ang)*2.5);
            mgr.add(h); mgHandles.push(h);
        }
        mgr.position.set(0, 0, -15); scene.add(mgr);

        // MONKEY BARS & SEESAW & SANDBOX
        const mBars = new THREE.Group();
        const mbTop = new THREE.Mesh(new THREE.BoxGeometry(6, 0.2, 2), new THREE.MeshStandardMaterial({color: 0x8b4513}));
        mbTop.position.y = 3; mBars.add(mbTop);
        mBars.position.set(15, 0, 15); scene.add(mBars);

        const sandbox = new THREE.Mesh(new THREE.BoxGeometry(8, 0.4, 8), new THREE.MeshStandardMaterial({ color: 0xf4a460 }));
        sandbox.position.set(-15, 0.2, 15); scene.add(sandbox);

        const seesaw = new THREE.Group();
        const ssPlank = new THREE.Mesh(new THREE.BoxGeometry(6, 0.1, 0.6), new THREE.MeshStandardMaterial({ color: 0xff6600 }));
        ssPlank.position.y = 0.5; seesaw.add(ssPlank);
        seesaw.position.set(0, 0, 15); scene.add(seesaw);

        // --- 6. WEAPONS, TOOLS & BLOCKS ---
        
        // Torso Ammo Spawner
        const ammoSpawner = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.15, 0.1),
            new THREE.MeshStandardMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4, wireframe: true })
        );
        scene.add(ammoSpawner);

        function spawnSword(x, z) {
            const g = new THREE.Group();
            const blade = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.8, 0.06), new THREE.MeshStandardMaterial({color: 0xcccccc, metalness: 0.8}));
            blade.position.y = 0.5;
            const hilt = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.03, 0.08), new THREE.MeshStandardMaterial({color: 0x444444}));
            hilt.position.y = 0.1;
            g.add(blade, hilt); g.position.set(x, 0.5, z); scene.add(g);
            new PhysicsObject(g, 'sword');
        }

        function spawnGun(x, z) {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.08, 0.25), new THREE.MeshStandardMaterial({color: 0x111111}));
            const gr = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.12, 0.06), new THREE.MeshStandardMaterial({color: 0x222222}));
            gr.position.set(0, -0.08, 0.08); g.add(b, gr);
            g.position.set(x, 1, z); scene.add(g);
            const po = new PhysicsObject(g, 'gun');
            po.ammoCount = 0;
        }

        function spawnBlock(x, z, color) {
            const b = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshStandardMaterial({color}));
            b.position.set(x, 0.5, z); b.castShadow = true;
            scene.add(b); new PhysicsObject(b, 'block');
        }

        // Initialize World Props
        spawnGun(2, 2); spawnSword(-2, 2);
        for(let i=0; i<8; i++) spawnBlock(Math.random()*4-2, 0.5, Math.random()*0xffffff);

        // --- 7. NPC SYSTEM (WITH HEALTH BARS) ---
        const npcs = [];
        function createNPC(x, z) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.3, 1), new THREE.MeshStandardMaterial({color: 0xff4444}));
            body.position.y = 0.8;
            
            const hbGeo = new THREE.PlaneGeometry(0.6, 0.06);
            const hbMat = new THREE.MeshBasicMaterial({color: 0x00ff00, side: THREE.DoubleSide});
            const hb = new THREE.Mesh(hbGeo, hbMat);
            hb.position.y = 2.0;
            
            group.add(body, hb);
            group.position.set(x, 0, z);
            group.userData = { health: 100, bar: hb, dir: Math.random()*Math.PI*2 };
            scene.add(group); npcs.push(group);
        }
        for(let i=0; i<5; i++) createNPC(Math.random()*20-10, -20-Math.random()*10);

        // --- 8. TARGET GAME ---
        const targets = [];
        for(let i=0; i<3; i++) {
            const t = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.05, 16, 32), new THREE.MeshBasicMaterial({color: 0xffffff}));
            t.position.set(-4+i*4, 2.5, -25);
            scene.add(t); targets.push(t);
        }

        // --- 9. VR INTERACTION & LOCOMOTION ---
        const modelFactory = new XRControllerModelFactory();
        const grabRange = 0.5;
        let mgVel = 0, activeMGHand = null, lastMGAngle = 0;

        function onSqueezeStart(e) {
            const c = e.target;
            const hPos = new THREE.Vector3().setFromMatrixPosition(c.matrixWorld);

            // Torso Check (Ammo)
            if (hPos.distanceTo(ammoSpawner.position) < 0.25) {
                const m = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.12, 0.05), new THREE.MeshStandardMaterial({color: 0xffcc00}));
                scene.add(m);
                const po = new PhysicsObject(m, 'ammo');
                po.grab(); c.attach(m); c.userData.selected = po;
                return;
            }

            // Merry-Go-Round Check
            mgHandles.forEach(h => {
                if (hPos.distanceTo(new THREE.Vector3().setFromMatrixPosition(h.matrixWorld)) < grabRange) {
                    activeMGHand = c;
                    const loc = mgr.worldToLocal(hPos.clone());
                    lastMGAngle = Math.atan2(loc.z, loc.x);
                }
            });

            // Grab World Items
            let closest = null, minD = grabRange;
            physicsObjects.forEach(obj => {
                const d = hPos.distanceTo(new THREE.Vector3().setFromMatrixPosition(obj.mesh.matrixWorld));
                if (d < minD) { minD = d; closest = obj; }
            });
            if (closest && !closest.isGrabbed) {
                closest.grab(); c.attach(closest.mesh); c.userData.selected = closest;
            }
        }

        function onSqueezeEnd(e) {
            const c = e.target;
            if (activeMGHand === c) activeMGHand = null;
            if (c.userData.selected) {
                const obj = c.userData.selected;
                scene.attach(obj.mesh);
                obj.release(obj.velocity); // Physical throw!
                c.userData.selected = null;
            }
        }

        function onSelectStart(e) {
            const c = e.target;
            const held = c.userData.selected;
            if (held && held.type === 'gun' && held.ammoCount > 0) {
                const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.03), new THREE.MeshBasicMaterial({color: 0xffff00}));
                bullet.position.setFromMatrixPosition(c.matrixWorld);
                scene.add(bullet);
                const pb = new PhysicsObject(bullet, 'bullet');
                const dir = new THREE.Vector3(0,0,-1).applyQuaternion(c.quaternion).normalize();
                pb.velocity.copy(dir.multiplyScalar(45));
                held.ammoCount--;
            }
        }

        for (let i = 0; i < 2; i++) {
            const c = renderer.xr.getController(i);
            c.addEventListener('squeezestart', onSqueezeStart);
            c.addEventListener('squeezeend', onSqueezeEnd);
            c.addEventListener('selectstart', onSelectStart);
            cameraGroup.add(c);
            const g = renderer.xr.getControllerGrip(i);
            g.add(modelFactory.createControllerModel(g));
            cameraGroup.add(g);
        }

        // --- 10. MAIN ANIMATION LOOP ---
        const clock = new THREE.Clock();
        renderer.setAnimationLoop(() => {
            const dt = Math.min(clock.getDelta(), 0.1);
            const session = renderer.xr.getSession();

            // THUMBSTICK LOCOMOTION
            if (session) {
                for (const source of session.inputSources) {
                    if (source.gamepad) {
                        const axes = source.gamepad.axes;
                        if (source.handedness === 'left') { // Move
                            const headYaw = camera.rotation.y;
                            cameraGroup.position.x += (axes[2] * Math.cos(headYaw) + axes[3] * Math.sin(headYaw)) * 3 * dt;
                            cameraGroup.position.z += (axes[3] * Math.cos(headYaw) - axes[2] * Math.sin(headYaw)) * 3 * dt;
                        } else if (source.handedness === 'right') { // Turn
                            if (Math.abs(axes[2]) > 0.5) cameraGroup.rotation.y -= Math.sign(axes[2]) * 0.05;
                        }
                    }
                }
            }

            // TORSO AMMO POSITIONING
            const headPos = new THREE.Vector3();
            camera.getWorldPosition(headPos);
            ammoSpawner.position.set(headPos.x, headPos.y - 0.5, headPos.z);
            ammoSpawner.rotation.y = camera.rotation.y;

            // MERRY-GO-ROUND SPIN
            if (activeMGHand) {
                const loc = mgr.worldToLocal(new THREE.Vector3().setFromMatrixPosition(activeMGHand.matrixWorld));
                const cur = Math.atan2(loc.z, loc.x);
                mgVel = (cur - lastMGAngle) / dt;
                lastMGAngle = cur;
            }
            mgr.rotation.y += mgVel * dt;
            mgVel *= 0.98;

            // PHYSICS & RELOAD & COMBAT
            physicsObjects.forEach(obj => {
                if (obj.isDead) return;
                obj.update(dt);

                // Reload Gun
                if (obj.type === 'ammo' && obj.isGrabbed) {
                    physicsObjects.forEach(g => {
                        if (g.type === 'gun' && obj.mesh.position.distanceTo(g.mesh.position) < 0.2) {
                            g.ammoCount = 10;
                            scene.remove(obj.mesh); obj.isDead = true;
                        }
                    });
                }

                // Bullet Hits
                if (obj.type === 'bullet') {
                    npcs.forEach(n => {
                        if (obj.mesh.position.distanceTo(n.position.clone().add(new THREE.Vector3(0,0.8,0))) < 0.6) {
                            n.userData.health -= 25;
                            n.userData.bar.scale.x = Math.max(0, n.userData.health/100);
                            scene.remove(obj.mesh); obj.isDead = true;
                        }
                    });
                    targets.forEach(t => {
                        if(obj.mesh.position.distanceTo(t.position) < 0.5) {
                            t.material.color.set(0x00ff00);
                            setTimeout(()=> t.material.color.set(0xffffff), 300);
                        }
                    });
                }
            });

            // NPC WANDER
            npcs.forEach(n => {
                if (n.userData.health <= 0) { n.rotation.x = Math.PI/2; return; } // Dead state
                n.position.x += Math.cos(n.userData.dir) * 0.5 * dt;
                n.position.z += Math.sin(n.userData.dir) * 0.5 * dt;
                if(Math.abs(n.position.x)>40 || Math.abs(n.position.z)>40) n.userData.dir += Math.PI;
            });

            if (!renderer.xr.isPresenting) controls.update();
            renderer.render(scene, camera);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
