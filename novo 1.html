<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>VR Playground - Ultra Edition</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            color: white; 
            background: rgba(0,0,0,0.8); 
            padding: 15px; 
            border-radius: 8px; 
            z-index: 100;
            font-family: sans-serif;
        }
    </style>
</head>
<body>
    <div id="info">Building World...</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // --- CORE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 0, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 1.6, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);

        // --- LIGHTING ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(20, 30, 20);
        sun.castShadow = true;
        sun.shadow.camera.left = -30;
        sun.shadow.camera.right = 30;
        sun.shadow.camera.top = 30;
        sun.shadow.camera.bottom = -30;
        sun.shadow.mapSize.set(2048, 2048);
        scene.add(sun);
        scene.add(new THREE.HemisphereLight(0x87ceeb, 0x4a7c59, 0.4));

        // --- GROUND ---
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshStandardMaterial({ color: 0x66bb66, roughness: 0.8 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- PHYSICS SYSTEM ---
        const physicsObjects = [];
        class PhysicsObject {
            constructor(mesh) {
                this.mesh = mesh;
                this.velocity = new THREE.Vector3();
                this.isGrabbed = false;
                physicsObjects.push(this);
            }
            update(dt) {
                if (this.isGrabbed) return;
                this.velocity.y += -9.8 * dt;
                this.mesh.position.addScaledVector(this.velocity, dt);
                if (this.mesh.position.y < 0.1) {
                    this.mesh.position.y = 0.1;
                    this.velocity.y *= -0.3;
                    this.velocity.multiplyScalar(0.9);
                }
            }
            grab() { this.isGrabbed = true; this.velocity.set(0,0,0); }
            release(vel) { this.isGrabbed = false; this.velocity.copy(vel); }
        }

        // --- PLAYGROUND EQUIPMENT ---

        // 1. SLIDE
        const slideGroup = new THREE.Group();
        const sPlatform = new THREE.Mesh(new THREE.BoxGeometry(3, 0.3, 3), new THREE.MeshStandardMaterial({ color: 0xff6600 }));
        sPlatform.position.y = 3;
        const sRamp = new THREE.Mesh(new THREE.BoxGeometry(3, 0.3, 5.5), new THREE.MeshStandardMaterial({ color: 0xffcc00 }));
        sRamp.position.set(0, 1.5, 3.5); sRamp.rotation.x = -0.55;
        slideGroup.add(sPlatform, sRamp);
        for(let i=0; i<4; i++) {
            const p = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 3), new THREE.MeshStandardMaterial({ color: 0x8b4513 }));
            p.position.set(i<2 ? -1.3 : 1.3, 1.5, i%2===0 ? -1.3 : 1.3);
            slideGroup.add(p);
        }
        slideGroup.position.set(-12, 0, -12);
        scene.add(slideGroup);

        // 2. SWING SET
        const swingSet = new THREE.Group();
        const sTop = new THREE.Mesh(new THREE.BoxGeometry(8, 0.3, 0.3), new THREE.MeshStandardMaterial({ color: 0x8b4513 }));
        sTop.position.y = 4; swingSet.add(sTop);
        for(let i=0; i<2; i++) {
            const p = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 4), new THREE.MeshStandardMaterial({ color: 0x8b4513 }));
            p.position.set(i===0 ? -3.8 : 3.8, 2, 0); swingSet.add(p);
        }
        for(let i=0; i<3; i++) {
            const seat = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.4), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
            seat.position.set(-2.5 + i * 2.5, 1.2, 0); swingSet.add(seat);
        }
        swingSet.position.set(12, 0, -12);
        scene.add(swingSet);

        // 3. INTERACTIVE MERRY-GO-ROUND
        const merryGoRound = new THREE.Group();
        const mgBase = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0xff00ff }));
        mgBase.position.y = 0.1; merryGoRound.add(mgBase);
        const mgHandles = [];
        for (let i = 0; i < 8; i++) {
            const h = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.2), new THREE.MeshStandardMaterial({ color: 0xffff00 }));
            const angle = (i / 8) * Math.PI * 2;
            h.position.set(Math.cos(angle) * 2.5, 0.6, Math.sin(angle) * 2.5);
            merryGoRound.add(h); mgHandles.push(h);
        }
        merryGoRound.position.set(0, 0, -12);
        scene.add(merryGoRound);

        // 4. SANDBOX
        const sandbox = new THREE.Mesh(new THREE.BoxGeometry(6, 0.4, 6), new THREE.MeshStandardMaterial({ color: 0xf4a460 }));
        sandbox.position.set(-12, 0.2, 12);
        scene.add(sandbox);

        // 5. MONKEY BARS
        const mBars = new THREE.Group();
        const mTop = new THREE.Mesh(new THREE.BoxGeometry(6.5, 0.2, 0.2), new THREE.MeshStandardMaterial({ color: 0x8b4513 }));
        mTop.position.y = 3; mBars.add(mTop);
        for(let i=0; i<10; i++) {
            const r = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.8), new THREE.MeshStandardMaterial({ color: 0xffff00 }));
            r.position.set(-2.8 + i*0.6, 3, 0); r.rotation.z = Math.PI/2; mBars.add(r);
        }
        mBars.position.set(12, 0, 12);
        scene.add(mBars);

        // 6. SEESAW
        const seesaw = new THREE.Group();
        const ssBase = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 0.6), new THREE.MeshStandardMaterial({ color: 0x8b4513 }));
        const ssPlank = new THREE.Mesh(new THREE.BoxGeometry(6, 0.1, 0.6), new THREE.MeshStandardMaterial({ color: 0xff6600 }));
        ssPlank.position.y = 0.5; seesaw.add(ssBase, ssPlank);
        seesaw.position.set(0, 0, 12);
        scene.add(seesaw);

        // --- TOOLS ---
        function spawnTool(type, x, z) {
            const g = new THREE.Group();
            if(type==='hammer') {
                const h = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.4), new THREE.MeshStandardMaterial({color: 0x8B4513}));
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.06, 0.06), new THREE.MeshStandardMaterial({color: 0x333333}));
                head.position.y = 0.2; g.add(h, head);
            } else {
                const h = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.3, 0.015), new THREE.MeshStandardMaterial({color: 0xaaaaaa}));
                const head = new THREE.Mesh(new THREE.TorusGeometry(0.04, 0.01, 8, 6), new THREE.MeshStandardMaterial({color: 0x888888}));
                head.position.y = 0.15; head.rotation.x = Math.PI/2; g.add(h, head);
            }
            g.position.set(x, 0.5, z); scene.add(g); new PhysicsObject(g);
        }
        spawnTool('hammer', 2, 2); spawnTool('wrench', 3, 2);

        // --- NPCs ---
        const npcs = [];
        class NPC {
            constructor(x, z, color) {
                this.group = new THREE.Group();
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1.2), new THREE.MeshStandardMaterial({ color }));
                body.position.y = 1; this.group.add(body);
                this.group.position.set(x, 0, z);
                this.dir = Math.random() * Math.PI * 2;
                scene.add(this.group); npcs.push(this);
            }
            update(dt) {
                this.group.position.x += Math.cos(this.dir) * 0.5 * dt;
                this.group.position.z += Math.sin(this.dir) * 0.5 * dt;
                if(Math.abs(this.group.position.x)>25 || Math.abs(this.group.position.z)>25) this.dir += Math.PI;
            }
        }
        for(let i=0; i<5; i++) new NPC(Math.random()*10-5, Math.random()*10-5, Math.random()*0xffffff);

        // --- VR INTERACTION LOGIC ---
        const modelFactory = new XRControllerModelFactory();
        const grabRange = 0.5;
        let mgVelocity = 0, activeMGHand = null, lastMGAngle = 0;

        function onSqueezeStart(e) {
            const controller = e.target;
            const handPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);

            // 1. Check Merry-Go-Round Handles
            mgHandles.forEach(h => {
                const hWorldPos = new THREE.Vector3().setFromMatrixPosition(h.matrixWorld);
                if (handPos.distanceTo(hWorldPos) < grabRange) {
                    activeMGHand = controller;
                    const localHand = merryGoRound.worldToLocal(handPos.clone());
                    lastMGAngle = Math.atan2(localHand.z, localHand.x);
                }
            });

            // 2. Check Physics Tools
            if (!activeMGHand) {
                let closest = null, minD = grabRange;
                physicsObjects.forEach(obj => {
                    const d = handPos.distanceTo(new THREE.Vector3().setFromMatrixPosition(obj.mesh.matrixWorld));
                    if (d < minD) { minD = d; closest = obj; }
                });
                if (closest && !closest.isGrabbed) {
                    closest.grab(); controller.attach(closest.mesh);
                    controller.userData.selected = closest;
                }
            }
        }

        function onSqueezeEnd(e) {
            const c = e.target;
            if (activeMGHand === c) activeMGHand = null;
            if (c.userData.selected) {
                scene.attach(c.userData.selected.mesh);
                c.userData.selected.release(new THREE.Vector3(0,0,0));
                c.userData.selected = null;
            }
        }

        for (let i = 0; i < 2; i++) {
            const c = renderer.xr.getController(i);
            c.addEventListener('squeezestart', onSqueezeStart);
            c.addEventListener('squeezeend', onSqueezeEnd);
            scene.add(c);
            const grip = renderer.xr.getControllerGrip(i);
            grip.add(modelFactory.createControllerModel(grip));
            scene.add(grip);
        }

        // --- MAIN LOOP ---
        const clock = new THREE.Clock();
        renderer.setAnimationLoop(() => {
            const dt = Math.min(clock.getDelta(), 0.1);

            // MG Spin Physics
            if (activeMGHand) {
                const handPos = new THREE.Vector3().setFromMatrixPosition(activeMGHand.matrixWorld);
                const localHand = merryGoRound.worldToLocal(handPos.clone());
                const currentAngle = Math.atan2(localHand.z, localHand.x);
                mgVelocity = (currentAngle - lastMGAngle) / dt;
                lastMGAngle = currentAngle;
            }
            merryGoRound.rotation.y += mgVelocity * dt;
            mgVelocity *= 0.98;

            physicsObjects.forEach(o => o.update(dt));
            npcs.forEach(n => n.update(dt));
            if (!renderer.xr.isPresenting) controls.update();
            renderer.render(scene, camera);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        info.innerHTML = "VR Ready: Use Side Grip Buttons";
    </script>
</body>
</html>
