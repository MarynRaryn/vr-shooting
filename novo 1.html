<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>VR Playground</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            color: white; 
            background: rgba(0,0,0,0.8); 
            padding: 15px; 
            border-radius: 8px; 
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">Loading playground...</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        const info = document.getElementById('info');
        info.innerHTML = 'Building playground...';

        // Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 0, 100);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 1.6, 10);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // VR Button
        document.body.appendChild(VRButton.createButton(renderer));

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.update();

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(20, 30, 20);
        sun.castShadow = true;
        sun.shadow.camera.left = -30;
        sun.shadow.camera.right = 30;
        sun.shadow.camera.top = 30;
        sun.shadow.camera.bottom = -30;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        scene.add(sun);

        scene.add(new THREE.HemisphereLight(0x87ceeb, 0x4a7c59, 0.4));

        // Ground - colorful grass
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshStandardMaterial({ 
                color: 0x66bb66,
                roughness: 0.8
            })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Add playground equipment
        info.innerHTML = 'Adding playground equipment...';

        // Slide
        const slideGroup = new THREE.Group();
        const slidePlatform = new THREE.Mesh(
            new THREE.BoxGeometry(3, 0.3, 3),
            new THREE.MeshStandardMaterial({ color: 0xff6600 })
        );
        slidePlatform.position.set(0, 3, 0);
        slidePlatform.castShadow = true;
        slideGroup.add(slidePlatform);

        const slideRamp = new THREE.Mesh(
            new THREE.BoxGeometry(3, 0.3, 5),
            new THREE.MeshStandardMaterial({ color: 0xffcc00 })
        );
        slideRamp.position.set(0, 1.5, 3.5);
        slideRamp.rotation.x = -0.5;
        slideRamp.castShadow = true;
        slideGroup.add(slideRamp);

        // Slide supports
        for (let i = 0; i < 4; i++) {
            const support = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 3, 8),
                new THREE.MeshStandardMaterial({ color: 0x8b4513 })
            );
            const x = i < 2 ? -1.3 : 1.3;
            const z = i % 2 === 0 ? -1.3 : 1.3;
            support.position.set(x, 1.5, z);
            support.castShadow = true;
            slideGroup.add(support);
        }
        slideGroup.position.set(-10, 0, -10);
        scene.add(slideGroup);

        // Swing set
        const swingSet = new THREE.Group();
        
        // Frame
        const frameTop = new THREE.Mesh(
            new THREE.BoxGeometry(8, 0.3, 0.3),
            new THREE.MeshStandardMaterial({ color: 0x8b4513 })
        );
        frameTop.position.y = 4;
        frameTop.castShadow = true;
        swingSet.add(frameTop);

        // Posts
        for (let i = 0; i < 2; i++) {
            const post = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 4, 8),
                new THREE.MeshStandardMaterial({ color: 0x8b4513 })
            );
            post.position.set(i === 0 ? -3.8 : 3.8, 2, 0);
            post.castShadow = true;
            swingSet.add(post);
        }

        // Swings
        for (let i = 0; i < 3; i++) {
            const seat = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.1, 0.4),
                new THREE.MeshStandardMaterial({ color: 0xff0000 })
            );
            seat.position.set(-2.5 + i * 2.5, 1.5, 0);
            seat.castShadow = true;
            swingSet.add(seat);

            // Chains
            for (let j = 0; j < 2; j++) {
                const chain = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, 2.5, 6),
                    new THREE.MeshStandardMaterial({ color: 0x444444 })
                );
                chain.position.set(-2.5 + i * 2.5 + (j === 0 ? -0.2 : 0.2), 2.75, 0);
                swingSet.add(chain);
            }
        }
        swingSet.position.set(10, 0, -10);
        scene.add(swingSet);

        // Merry-go-round
        const merryGoRound = new THREE.Group();
        const platform = new THREE.Mesh(
            new THREE.CylinderGeometry(2.5, 2.5, 0.3, 32),
            new THREE.MeshStandardMaterial({ color: 0xff00ff })
        );
        platform.position.y = 0.15;
        platform.castShadow = true;
        merryGoRound.add(platform);

        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const handle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 1, 8),
                new THREE.MeshStandardMaterial({ color: 0xffff00 })
            );
            handle.position.set(Math.cos(angle) * 2, 0.65, Math.sin(angle) * 2);
            handle.castShadow = true;
            merryGoRound.add(handle);
        }
        merryGoRound.position.set(0, 0, -10);
        scene.add(merryGoRound);

        // Sandbox
        const sandbox = new THREE.Mesh(
            new THREE.BoxGeometry(6, 0.5, 6),
            new THREE.MeshStandardMaterial({ color: 0xf4a460 })
        );
        sandbox.position.set(-10, 0.25, 10);
        sandbox.castShadow = true;
        scene.add(sandbox);

        // Sandbox border
        const borderMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
        for (let i = 0; i < 4; i++) {
            const border = new THREE.Mesh(
                new THREE.BoxGeometry(i % 2 === 0 ? 6.5 : 0.3, 0.3, i % 2 === 0 ? 0.3 : 6.5),
                borderMaterial
            );
            const x = i === 1 ? 3.25 : i === 3 ? -3.25 : 0;
            const z = i === 0 ? 3.25 : i === 2 ? -3.25 : 0;
            border.position.set(-10 + x, 0.5, 10 + z);
            border.castShadow = true;
            scene.add(border);
        }

        // Monkey bars
        const monkeyBars = new THREE.Group();
        for (let i = 0; i < 2; i++) {
            const post = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 3, 8),
                new THREE.MeshStandardMaterial({ color: 0x8b4513 })
            );
            post.position.set(i === 0 ? -3 : 3, 1.5, 0);
            post.castShadow = true;
            monkeyBars.add(post);
        }

        const topBar = new THREE.Mesh(
            new THREE.BoxGeometry(6.5, 0.2, 0.2),
            new THREE.MeshStandardMaterial({ color: 0x8b4513 })
        );
        topBar.position.y = 3;
        topBar.castShadow = true;
        monkeyBars.add(topBar);

        for (let i = 0; i < 10; i++) {
            const rung = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 0.6, 8),
                new THREE.MeshStandardMaterial({ color: 0xffff00 })
            );
            rung.position.set(-2.5 + i * 0.6, 3, 0);
            rung.rotation.z = Math.PI / 2;
            rung.castShadow = true;
            monkeyBars.add(rung);
        }
        monkeyBars.position.set(10, 0, 10);
        scene.add(monkeyBars);

        // Seesaw
        const seesaw = new THREE.Group();
        const base = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.4, 0.5, 8),
            new THREE.MeshStandardMaterial({ color: 0x8b4513 })
        );
        base.position.y = 0.25;
        base.castShadow = true;
        seesaw.add(base);

        const plank = new THREE.Mesh(
            new THREE.BoxGeometry(6, 0.2, 0.6),
            new THREE.MeshStandardMaterial({ color: 0xff6600 })
        );
        plank.position.y = 0.5;
        plank.castShadow = true;
        seesaw.add(plank);

        for (let i = 0; i < 2; i++) {
            const seat = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.5, 0.5),
                new THREE.MeshStandardMaterial({ color: 0x00ff00 })
            );
            seat.position.set(i === 0 ? -2.5 : 2.5, 0.75, 0);
            seat.castShadow = true;
            seesaw.add(seat);
        }
        seesaw.position.set(0, 0, 10);
        scene.add(seesaw);

        // Create throwable objects
        info.innerHTML = 'Adding toys...';
        const physicsObjects = [];
        const npcs = [];
        let draggedObject = null;

        class PhysicsObject {
            constructor(mesh) {
                this.mesh = mesh;
                this.velocity = new THREE.Vector3();
                this.isGrabbed = false;
                physicsObjects.push(this);
            }

            update(dt) {
                if (this.isGrabbed) return;
                this.velocity.y += -9.8 * dt;
                this.mesh.position.addScaledVector(this.velocity, dt);
                
                if (this.mesh.position.y < 0.3) {
                    this.mesh.position.y = 0.3;
                    this.velocity.y = Math.abs(this.velocity.y) * 0.4;
                    this.velocity.x *= 0.8;
                    this.velocity.z *= 0.8;
                }
                this.velocity.multiplyScalar(0.98);
            }

            grab() { 
                this.isGrabbed = true; 
                this.velocity.set(0, 0, 0); 
            }
            
            release(vel) { 
                this.isGrabbed = false; 
                this.velocity.copy(vel); 
            }
        }

        // Balls
        for (let i = 0; i < 8; i++) {
            const ball = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xff8800, 0x88ff00][i]
                })
            );
            ball.position.set(-8 + i * 2, 1, 0);
            ball.castShadow = true;
            scene.add(ball);
            new PhysicsObject(ball);
        }

        // NPCs
        class NPC {
            constructor(x, z, color) {
                this.group = new THREE.Group();
                this.health = 100;
                this.color = color;
                
                const body = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8),
                    new THREE.MeshStandardMaterial({ color })
                );
                body.position.y = 1;
                body.castShadow = true;
                this.body = body;
                this.group.add(body);
                
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.25, 16, 16),
                    new THREE.MeshStandardMaterial({ color: 0xffdbac })
                );
                head.position.y = 1.7;
                head.castShadow = true;
                this.group.add(head);
                
                const leftEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05),
                    new THREE.MeshStandardMaterial({ color: 0x000000 })
                );
                leftEye.position.set(-0.1, 1.75, 0.2);
                this.group.add(leftEye);
                
                const rightEye = leftEye.clone();
                rightEye.position.x = 0.1;
                this.group.add(rightEye);
                
                this.leftArm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8),
                    new THREE.MeshStandardMaterial({ color })
                );
                this.leftArm.position.set(-0.4, 1, 0);
                this.leftArm.rotation.z = 0.3;
                this.group.add(this.leftArm);
                
                this.rightArm = this.leftArm.clone();
                this.rightArm.material = this.leftArm.material.clone();
                this.rightArm.position.x = 0.4;
                this.rightArm.rotation.z = -0.3;
                this.group.add(this.rightArm);
                
                this.group.position.set(x, 0, z);
                scene.add(this.group);
                
                this.time = Math.random() * 100;
                this.direction = Math.random() * Math.PI * 2;
                npcs.push(this);
            }

            update(dt) {
                this.time += dt;
                this.leftArm.rotation.x = Math.sin(this.time * 3) * 0.4;
                this.rightArm.rotation.x = -Math.sin(this.time * 3) * 0.4;
                this.group.position.y = Math.abs(Math.sin(this.time * 5)) * 0.08;
                
                this.group.position.x += Math.cos(this.direction) * 0.5 * dt;
                this.group.position.z += Math.sin(this.direction) * 0.5 * dt;
                
                if (Math.abs(this.group.position.x) > 30 || Math.abs(this.group.position.z) > 30) {
                    this.direction += Math.PI;
                }
                
                if (Math.random() < 0.01) {
                    this.direction += (Math.random() - 0.5) * 1;
                }
                
                this.group.rotation.y = this.direction;
            }
        }

        // Spawn NPCs
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            new NPC(Math.cos(angle) * 15, Math.sin(angle) * 15, [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff][i]);
        }

        // VR Controllers
        const controllerModelFactory = new XRControllerModelFactory();
        const controllers = [];

        for (let i = 0; i < 2; i++) {
            const controller = renderer.xr.getController(i);
            controller.userData.grabbed = null;
            
            controller.addEventListener('selectstart', (e) => {
                const raycaster = new THREE.Raycaster();
                const tempMatrix = new THREE.Matrix4();
                controller.updateMatrixWorld();
                tempMatrix.identity().extractRotation(controller.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                
                const intersects = raycaster.intersectObjects(physicsObjects.map(o => o.mesh));
                if (intersects.length > 0) {
                    const obj = physicsObjects.find(o => o.mesh === intersects[0].object);
                    if (obj) {
                        obj.grab();
                        controller.userData.grabbed = obj;
                        controller.attach(obj.mesh);
                    }
                }
            });
            
            controller.addEventListener('selectend', (e) => {
                if (controller.userData.grabbed) {
                    const obj = controller.userData.grabbed;
                    scene.attach(obj.mesh);
                    obj.release(new THREE.Vector3(0, 2, -5));
                    controller.userData.grabbed = null;
                }
            });
            
            scene.add(controller);
            
            const grip = renderer.xr.getControllerGrip(i);
            grip.add(controllerModelFactory.createControllerModel(grip));
            scene.add(grip);
            
            controllers.push(controller);
        }

        // Mouse controls
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let dragPlane = new THREE.Plane();
        let dragOffset = new THREE.Vector3();
        let prevMouse = new THREE.Vector2();
        let mouseVel = new THREE.Vector2();

        renderer.domElement.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(physicsObjects.map(o => o.mesh));
            if (hits.length > 0) {
                controls.enabled = false;
                const obj = physicsObjects.find(o => o.mesh === hits[0].object);
                if (obj) {
                    draggedObject = obj;
                    obj.grab();
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    dragPlane.setFromNormalAndCoplanarPoint(dir, obj.mesh.position);
                    const pt = new THREE.Vector3();
                    raycaster.ray.intersectPlane(dragPlane, pt);
                    dragOffset.subVectors(obj.mesh.position, pt);
                }
            }
            prevMouse.set(e.clientX, e.clientY);
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (draggedObject) {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const pt = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, pt);
                draggedObject.mesh.position.copy(pt.add(dragOffset));
                mouseVel.set(e.clientX - prevMouse.x, e.clientY - prevMouse.y);
                prevMouse.set(e.clientX, e.clientY);
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            if (draggedObject) {
                const v = new THREE.Vector3(mouseVel.x * 0.05, -mouseVel.y * 0.05, 0);
                const right = new THREE.Vector3();
                const up = new THREE.Vector3();
                camera.getWorldDirection(right);
                up.copy(camera.up);
                right.cross(up).normalize();
                const worldV = new THREE.Vector3();
                worldV.addScaledVector(right, v.x);
                worldV.addScaledVector(up, v.y);
                draggedObject.release(worldV);
                draggedObject = null;
                controls.enabled = true;
            }
        });

        // Animate
        const clock = new THREE.Clock();
        info.innerHTML = 'âœ… Ready! Desktop: Click balls | VR: Use trigger';

        function animate() {
            const dt = Math.min(clock.getDelta(), 0.1);
            physicsObjects.forEach(o => o.update(dt));
            npcs.forEach(n => n.update(dt));
            if (!renderer.xr.isPresenting) controls.update();
            renderer.render(scene, camera);
        }

        renderer.setAnimationLoop(animate);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
