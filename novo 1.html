<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VR Combat Playground</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  body { overflow:hidden; background:#000; font-family:'Segoe UI',sans-serif; }
  #overlay {
    position:absolute; inset:0;
    background:linear-gradient(135deg,#0a0a1a 0%,#1a0a2e 50%,#0a1a2e 100%);
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    z-index:100; color:white;
  }
  #overlay h1 {
    font-size:64px; font-weight:900; letter-spacing:6px;
    background:linear-gradient(90deg,#00e5ff,#7c4dff,#00e5ff);
    background-size:200%; -webkit-background-clip:text; -webkit-text-fill-color:transparent;
    animation:shimmer 3s linear infinite; margin-bottom:8px;
  }
  @keyframes shimmer { 0%{background-position:0%} 100%{background-position:200%} }
  #overlay p { opacity:0.6; font-size:16px; margin-bottom:50px; letter-spacing:2px; }
  .btn-row { display:flex; gap:20px; flex-wrap:wrap; justify-content:center; }
  .big-btn {
    padding:18px 40px; font-size:20px; font-weight:bold; border:none;
    border-radius:12px; cursor:pointer; letter-spacing:2px; transition:all 0.2s;
    pointer-events:all;
  }
  #vr-btn {
    background:linear-gradient(135deg,#7c4dff,#00e5ff);
    color:white; box-shadow:0 0 30px rgba(124,77,255,0.6);
  }
  #vr-btn:hover { transform:scale(1.07); box-shadow:0 0 50px rgba(124,77,255,0.9); }
  #desktop-btn {
    background:rgba(255,255,255,0.1); color:white;
    border:2px solid rgba(255,255,255,0.3);
  }
  #desktop-btn:hover { background:rgba(255,255,255,0.2); transform:scale(1.04); }
  #vr-status { margin-top:20px; font-size:14px; opacity:0.5; }
  #hud { position:absolute; inset:0; pointer-events:none; z-index:10; display:none; }
  #ammo {
    position:absolute; bottom:30px; right:30px;
    color:#fff; font-size:26px; font-weight:bold;
    text-shadow:0 0 15px #00e5ff;
    background:rgba(0,0,0,0.6); padding:10px 22px;
    border-radius:10px; border:1px solid rgba(0,229,255,0.4);
  }
  #score-hud {
    position:absolute; top:20px; left:20px;
    color:#fff; font-size:16px; font-weight:bold;
    background:rgba(0,0,0,0.6); padding:12px 20px;
    border-radius:10px; border:1px solid rgba(255,255,255,0.15);
    line-height:2;
  }
  #crosshair { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); }
  #crosshair::before, #crosshair::after { content:''; position:absolute; background:rgba(255,255,255,0.85); border-radius:2px; }
  #crosshair::before { width:2px; height:18px; top:-9px; left:-1px; }
  #crosshair::after  { width:18px; height:2px; top:-1px; left:-9px; }
  #hitmarker { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); opacity:0; transition:opacity 0.05s; }
  #hitmarker.show { opacity:1; }
  #hitmarker::before, #hitmarker::after { content:''; position:absolute; background:#ff1744; border-radius:2px; }
  #hitmarker::before { width:2px; height:10px; top:-5px; left:-1px; }
  #hitmarker::after  { width:10px; height:2px; top:-1px; left:-5px; }
  #reload-bar { position:absolute; bottom:80px; right:30px; width:150px; height:8px; background:rgba(255,255,255,0.15); border-radius:4px; display:none; }
  #reload-fill { height:100%; background:linear-gradient(90deg,#00e5ff,#7c4dff); border-radius:4px; width:0%; }
  #wname { position:absolute; bottom:70px; right:30px; color:rgba(255,255,255,0.5); font-size:13px; text-align:right; }
  #controls-hint {
    position:absolute; bottom:20px; left:20px;
    color:rgba(255,255,255,0.7); font-size:12px;
    background:rgba(0,0,0,0.5); padding:10px 14px;
    border-radius:8px; line-height:1.9;
  }
  #wave-banner {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    font-size:52px; font-weight:900; color:white;
    text-shadow:0 0 40px #7c4dff; pointer-events:none;
    opacity:0; transition:opacity 0.5s;
  }
  #wave-banner.show { opacity:1; }
</style>
</head>
<body>

<div id="overlay">
  <h1>VR PLAYGROUND</h1>
  <p>COMBAT Â· DESTRUCTION Â· PHYSICS</p>
  <div class="btn-row">
    <button class="big-btn" id="vr-btn" onclick="enterVR()">ğŸ¥½ ENTER VR</button>
    <button class="big-btn" id="desktop-btn" onclick="enterDesktop()">ğŸ–¥ï¸ DESKTOP MODE</button>
  </div>
  <div id="vr-status">Checking VR support...</div>
</div>

<div id="hud">
  <div id="crosshair"></div>
  <div id="hitmarker"></div>
  <div id="ammo">30 / 90</div>
  <div id="wname">RIFLE</div>
  <div id="reload-bar"><div id="reload-fill"></div></div>
  <div id="score-hud">
    ğŸ’€ Kills: <span id="kills">0</span><br>
    ğŸ¯ Score: <span id="scoreVal">0</span><br>
    â¤ï¸ HP: <span id="hp">100</span><br>
    ğŸŒŠ Wave: <span id="wave">1</span>
  </div>
  <div id="controls-hint">
    <b>WASD</b> Move &nbsp; <b>Space</b> Jump<br>
    <b>Click</b> Shoot &nbsp; <b>R</b> Reload<br>
    <b>1</b> Pistol &nbsp; <b>2</b> Rifle &nbsp; <b>3</b> Shotgun<br>
    <b>G</b> Grenade &nbsp; <b>F</b> Unlock mouse
  </div>
</div>
<div id="wave-banner"></div>

<script type="importmap">
{"imports":{
  "three":"https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
  "three/addons/":"https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
}}
</script>
<script type="module">
import * as THREE from 'three';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

// â”€â”€ RENDERER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.xr.enabled = true;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.15;
document.body.appendChild(renderer.domElement);

// â”€â”€ SCENE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x7ecfea);
scene.fog = new THREE.FogExp2(0x7ecfea, 0.006);

// â”€â”€ PLAYER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const playerRig = new THREE.Group();
scene.add(playerRig);
playerRig.position.set(0, 0, 8);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.05, 400);
camera.position.set(0, 1.7, 0);
playerRig.add(camera);

// â”€â”€ VR SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ctrlFactory = new XRControllerModelFactory();
const vrControllers = [];
const vrGrips = [];
const grabbedObjects = [null, null];
const ctrlPrevPos = [new THREE.Vector3(), new THREE.Vector3()];
const ctrlVel = [new THREE.Vector3(), new THREE.Vector3()];

for (let i = 0; i < 2; i++) {
  const ctrl = renderer.xr.getController(i);
  ctrl.userData.index = i;
  ctrl.addEventListener('selectstart', onVRGrab);
  ctrl.addEventListener('selectend',   onVRRelease);
  ctrl.addEventListener('squeezestart', onVRGrab);
  ctrl.addEventListener('squeezeend',   onVRRelease);
  playerRig.add(ctrl);

  // Ray line
  const lineMat = new THREE.LineBasicMaterial({ color:0x00e5ff, transparent:true, opacity:0.6 });
  const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
  const ray = new THREE.Line(lineGeo, lineMat);
  ray.scale.z = 8;
  ray.name = 'ray';
  ctrl.add(ray);

  const grip = renderer.xr.getControllerGrip(i);
  grip.add(ctrlFactory.createControllerModel(grip));
  playerRig.add(grip);

  vrControllers.push(ctrl);
  vrGrips.push(grip);
}

function onVRGrab(e) {
  const ctrl = e.target;
  const i = ctrl.userData.index;
  if (grabbedObjects[i]) return;

  const raycaster = new THREE.Raycaster();
  const tmpM = new THREE.Matrix4();
  ctrl.updateMatrixWorld();
  tmpM.identity().extractRotation(ctrl.matrixWorld);
  raycaster.ray.origin.setFromMatrixPosition(ctrl.matrixWorld);
  raycaster.ray.direction.set(0,0,-1).applyMatrix4(tmpM);

  const grabMeshes = grabbable.map(g => g.mesh);
  const hits = raycaster.intersectObjects(grabMeshes, true);

  if (hits.length > 0) {
    let obj = hits[0].object;
    while (obj.parent && !grabMeshes.includes(obj)) obj = obj.parent;
    const phys = grabbable.find(g => g.mesh === obj || g.mesh.children.includes(obj));
    if (phys && !phys.heldBy) {
      phys.heldBy = i;
      grabbedObjects[i] = phys;
      phys.vel.set(0,0,0);
      phys.avel.set(0,0,0);
      ctrl.attach(phys.mesh);
      // Hide ray when holding
      ctrl.getObjectByName('ray').visible = false;
    }
  } else {
    // Shoot when trigger pressed and not grabbing
    shootVR(ctrl);
  }
}

function onVRRelease(e) {
  const ctrl = e.target;
  const i = ctrl.userData.index;
  if (grabbedObjects[i]) {
    const phys = grabbedObjects[i];
    scene.attach(phys.mesh);
    const throwVel = ctrlVel[i].clone().multiplyScalar(4);
    phys.vel.copy(throwVel);
    phys.avel.set((Math.random()-0.5)*8,(Math.random()-0.5)*8,(Math.random()-0.5)*8);
    phys.heldBy = null;
    grabbedObjects[i] = null;
    ctrl.getObjectByName('ray').visible = true;
  }
}

function shootVR(ctrl) {
  if (vrReloading || vrAmmo <= 0) { vrStartReload(); return; }
  vrAmmo--;
  const tmpM = new THREE.Matrix4();
  ctrl.updateMatrixWorld();
  tmpM.identity().extractRotation(ctrl.matrixWorld);
  const dir = new THREE.Vector3(0,0,-1).applyMatrix4(tmpM);
  const origin = new THREE.Vector3().setFromMatrixPosition(ctrl.matrixWorld);

  const b = new THREE.Mesh(bulletGeo, bulletMatY.clone());
  b.position.copy(origin).addScaledVector(dir, 0.3);
  b.userData = { vel:dir.clone().multiplyScalar(70), life:3, alive:true };
  scene.add(b);
  bullets.push(b);

  // Haptic feedback
  const gamepad = ctrl.inputSource?.gamepad;
  if (gamepad?.hapticActuators?.[0]) {
    gamepad.hapticActuators[0].pulse(0.6, 80);
  }
}

// VR ammo
let vrAmmo = 30, vrReloading = false;
function vrStartReload() {
  if (vrReloading) return;
  vrReloading = true;
  setTimeout(() => { vrAmmo = 30; vrReloading = false; }, 1800);
}

// â”€â”€ LIGHTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
scene.add(new THREE.AmbientLight(0xfff4e0, 0.45));
const sun = new THREE.DirectionalLight(0xfffde7, 1.1);
sun.position.set(60, 80, 40);
sun.castShadow = true;
sun.shadow.mapSize.set(4096, 4096);
sun.shadow.camera.left = -80; sun.shadow.camera.right = 80;
sun.shadow.camera.top  =  80; sun.shadow.camera.bottom = -80;
sun.shadow.bias = -0.0005;
scene.add(sun);
scene.add(new THREE.HemisphereLight(0x87ceeb, 0x4a7a2a, 0.4));

// â”€â”€ MATS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const M = {
  grass:   new THREE.MeshStandardMaterial({color:0x4caf50,roughness:0.9}),
  dirt:    new THREE.MeshStandardMaterial({color:0x6d4c41,roughness:1}),
  concrete:new THREE.MeshStandardMaterial({color:0x90a4ae,roughness:0.85}),
  metal:   new THREE.MeshStandardMaterial({color:0x546e7a,roughness:0.3,metalness:0.9}),
  wood:    new THREE.MeshStandardMaterial({color:0x8d6e63,roughness:0.9}),
  red:     new THREE.MeshStandardMaterial({color:0xef5350,roughness:0.7}),
  blue:    new THREE.MeshStandardMaterial({color:0x42a5f5,roughness:0.7}),
  yellow:  new THREE.MeshStandardMaterial({color:0xffee58,roughness:0.7}),
  orange:  new THREE.MeshStandardMaterial({color:0xffa726,roughness:0.7}),
  purple:  new THREE.MeshStandardMaterial({color:0xab47bc,roughness:0.7}),
  brick:   new THREE.MeshStandardMaterial({color:0xc62828,roughness:0.9}),
  sand:    new THREE.MeshStandardMaterial({color:0xffe082,roughness:1}),
  glass:   new THREE.MeshStandardMaterial({color:0xb3e5fc,roughness:0,metalness:0.1,transparent:true,opacity:0.3}),
};

// â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function box(w,h,d,mat,x,y,z,rx=0,ry=0) {
  const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
  m.position.set(x,y,z); m.rotation.set(rx,ry,0);
  m.castShadow = true; m.receiveShadow = true; scene.add(m); return m;
}
function cyl(rt,rb,h,seg,mat,x,y,z) {
  const m = new THREE.Mesh(new THREE.CylinderGeometry(rt,rb,h,seg), mat);
  m.position.set(x,y,z); m.castShadow = true; m.receiveShadow = true; scene.add(m); return m;
}
function sph(r,seg,mat,x,y,z) {
  const m = new THREE.Mesh(new THREE.SphereGeometry(r,seg,seg), mat);
  m.position.set(x,y,z); m.castShadow = true; scene.add(m); return m;
}

// â”€â”€ GROUND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), M.grass);
ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
box(4,0.05,80, M.dirt, 0,0.01,0);

// â”€â”€ WORLD BOUNDARY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[[0,1,55,110,2,1],[0,1,-55,110,2,1],[55,1,0,1,2,110],[-55,1,0,1,2,110]].forEach(([x,y,z,w,h,d])=>
  box(w,h,d, M.concrete, x,y,z));

// â”€â”€ BUILDINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeBuilding(x,z,w,d,h,col) {
  const bm = new THREE.MeshStandardMaterial({color:col,roughness:0.8});
  box(w,h,d, bm, x,h/2,z);
  box(w+0.3,0.4,d+0.3, new THREE.MeshStandardMaterial({color:0x37474f,roughness:0.7}), x,h+0.2,z);
  for(let fl=1; fl<Math.floor(h/3); fl++)
    for(let wi=0; wi<Math.floor(w/2.5); wi++)
      box(0.7,0.9,0.1, M.glass, x-w/2+1.2+wi*2.4, fl*3, z+d/2+0.06);
}
makeBuilding(-28,-22,10,8,12,0x607d8b);
makeBuilding( 28,-22,8,8,16,0x546e7a);
makeBuilding(-32,-38,14,10,9,0x78909c);
makeBuilding( 32,-38,10,12,20,0x455a64);

// â”€â”€ DESTRUCTIBLE WALLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const destructibles = [];
function makeDestructWall(px,pz,ry=0) {
  const g = new THREE.Group();
  g.position.set(px,0,pz); g.rotation.y=ry; scene.add(g);
  const bm = new THREE.MeshStandardMaterial({color:0xc62828,roughness:0.9});
  for(let r=0;r<4;r++) for(let c=0;c<6;c++) {
    const off = r%2===0?0:0.49;
    const br = new THREE.Mesh(new THREE.BoxGeometry(0.94,0.54,0.44), bm.clone());
    br.position.set(c*0.96-2.65+off, r*0.56+0.28, 0);
    br.castShadow=true; br.receiveShadow=true;
    br.userData = {vel:new THREE.Vector3(),avel:new THREE.Vector3(),falling:false,alive:true};
    g.add(br); destructibles.push({mesh:br,group:g});
  }
}
for(const [x,z,r] of [[-14,-8,0],[-14,-13,0],[14,-8,0],[14,-13,0],[0,-22,Math.PI/2],[0,-27,Math.PI/2],[-7,-18,0],[7,-18,0],[-14,5,0],[14,5,0]])
  makeDestructWall(x,z,r);

// â”€â”€ TARGETS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const targets = [];
function makeTarget(x,y,z,moving=false) {
  const g = new THREE.Group(); g.position.set(x,y,z); scene.add(g);
  const post = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.07,y,8), M.wood.clone());
  post.position.y = -y/2; post.castShadow=true; g.add(post);
  [[0.65,0xd32f2f],[0.5,0xffffff],[0.35,0xd32f2f],[0.22,0xffffff],[0.09,0xd32f2f]].forEach(([r,c])=>{
    const ring=new THREE.Mesh(new THREE.CylinderGeometry(r,r,0.04,32),
      new THREE.MeshStandardMaterial({color:c,roughness:0.5}));
    ring.rotation.x=Math.PI/2; g.add(ring);
  });
  g.userData = {health:3,alive:true,moving,baseX:x,phase:Math.random()*Math.PI*2,speed:0.4+Math.random()*0.8,range:2+Math.random()*2,spin:Math.random()>0.5,spinSpeed:(Math.random()-0.5)*1.5};
  targets.push(g); return g;
}
for(let i=0;i<7;i++) makeTarget(-14+i*4.5, 1.6, -20);
for(let i=0;i<4;i++) makeTarget(-8+i*5, 1.9, -32, true);
for(let i=0;i<3;i++) makeTarget(-5+i*5, 1.6, -40);
targets.forEach(t=>{ t.userData.baseX=t.position.x; });

// â”€â”€ PHYSICS BLOCKS (grabbable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const grabbable = [];
const blocks = [];

function makePhysBlock(x,y,z,mat,w=1,h=1,d=1) {
  const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat.clone());
  m.position.set(x,y,z); m.castShadow=true; m.receiveShadow=true; scene.add(m);
  const phys = {mesh:m, vel:new THREE.Vector3(), avel:new THREE.Vector3(), grounded:false, heldBy:null, type:'block'};
  blocks.push(phys); grabbable.push(phys); return phys;
}

// Sword (special grabbable)
function makeSword(x,y,z,bladeCol,handleCol) {
  const g = new THREE.Group(); g.position.set(x,y,z); scene.add(g);
  const blade=new THREE.Mesh(new THREE.BoxGeometry(0.1,1.7,0.055),
    new THREE.MeshStandardMaterial({color:bladeCol,metalness:0.95,roughness:0.05,emissive:bladeCol,emissiveIntensity:0.15}));
  blade.position.y=0.85; blade.castShadow=true; g.add(blade);
  const sheen=new THREE.Mesh(new THREE.BoxGeometry(0.04,1.7,0.02),
    new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.25}));
  sheen.position.set(0.02,0.85,0); g.add(sheen);
  const handle=new THREE.Mesh(new THREE.CylinderGeometry(0.09,0.09,0.48,10),
    new THREE.MeshStandardMaterial({color:handleCol,roughness:0.6}));
  handle.castShadow=true; g.add(handle);
  const guard=new THREE.Mesh(new THREE.BoxGeometry(0.46,0.07,0.11),
    new THREE.MeshStandardMaterial({color:0x8d6e63,metalness:0.5}));
  guard.position.y=0.24; g.add(guard);
  const pommel=new THREE.Mesh(new THREE.SphereGeometry(0.11,10,10),
    new THREE.MeshStandardMaterial({color:handleCol,metalness:0.5}));
  pommel.position.y=-0.28; g.add(pommel);
  const phys = {mesh:g, vel:new THREE.Vector3(), avel:new THREE.Vector3(), grounded:false, heldBy:null, type:'sword'};
  grabbable.push(phys); return phys;
}

// Grenade (grabbable + throwable)
function makeGrenade(x,y,z) {
  const g = new THREE.Group(); g.position.set(x,y,z); scene.add(g);
  const body=new THREE.Mesh(new THREE.SphereGeometry(0.13,10,10),
    new THREE.MeshStandardMaterial({color:0x33691e,metalness:0.6,roughness:0.4}));
  body.castShadow=true; g.add(body);
  const pin=new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,0.2,6),
    new THREE.MeshStandardMaterial({color:0x9e9e9e,metalness:0.9}));
  pin.position.set(0.1,0.14,0); pin.rotation.z=0.5; g.add(pin);
  const lever=new THREE.Mesh(new THREE.BoxGeometry(0.15,0.04,0.04),
    new THREE.MeshStandardMaterial({color:0x9e9e9e,metalness:0.8}));
  lever.position.set(0,0.14,0); g.add(lever);
  const phys = {mesh:g, vel:new THREE.Vector3(), avel:new THREE.Vector3(), grounded:false, heldBy:null, type:'grenade', armed:false, fuseTime:2.0, fuse:0};
  grabbable.push(phys); return phys;
}

// Spawn initial objects
const bmats=[M.red,M.blue,M.yellow,M.orange,M.purple,M.wood,M.concrete,M.metal];
for(let i=0;i<5;i++) makePhysBlock(12, 0.5+i, -10, M.metal, 1.2,1,1.2);
for(let i=0;i<35;i++) {
  const s=0.4+Math.random()*0.8;
  makePhysBlock(-22+Math.random()*44, s/2, -3+Math.random()*-22, bmats[i%bmats.length],s,s,s);
}
for(const [x,y,z,bc,hc] of [[-3,1.5,0,0xc0c0c0,0x8b0000],[3,1.5,0,0x4169e1,0x000088],[0,1.5,-3,0x50c878,0x006400],[0,1.5,3,0xffd700,0x8b6914]])
  makeSword(x,y,z,bc,hc);
for(const [x,y,z] of [[-2,0.8,2],[2,0.8,2],[0,0.8,4],[-4,0.8,0],[4,0.8,0]])
  makeGrenade(x,y,z);

// â”€â”€ BUNKERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeBunker(x,z) {
  box(6,1.5,1,M.concrete,x,0.75,z);
  box(1,1.5,3,M.concrete,x-2.5,0.75,z+1);
  box(1,1.5,3,M.concrete,x+2.5,0.75,z+1);
}
makeBunker(-8,-6); makeBunker(8,-6); makeBunker(0,-14); makeBunker(-20,5); makeBunker(20,5);

// â”€â”€ BARRELS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[[6,0,-5,0x388e3c],[7,0,-5,0x388e3c],[6,0,-6,0xd32f2f],[-6,0,-5,0x388e3c],[-7,0,-5,0x388e3c],
 [-6,0,-6,0xd32f2f],[13,0,-9,0xd32f2f],[13,0,-10,0x388e3c],[-13,0,-9,0x388e3c],
 [-20,0,3,0x388e3c],[20,0,3,0xd32f2f]].forEach(([x,,z,c])=>{
  const bm=new THREE.MeshStandardMaterial({color:c,roughness:0.6,metalness:0.4});
  cyl(0.34,0.37,0.9,16,bm,x,0.45,z);
  cyl(0.38,0.38,0.07,16,new THREE.MeshStandardMaterial({color:0x212121,metalness:0.8}),x,0.83,z);
  cyl(0.38,0.38,0.07,16,new THREE.MeshStandardMaterial({color:0x212121,metalness:0.8}),x,0.24,z);
});

// â”€â”€ PLAYGROUND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Slide
const sg=new THREE.Group(); sg.position.set(-22,0,10); scene.add(sg);
const slm=new THREE.MeshStandardMaterial({color:0xff7043,roughness:0.6});
for(const[x,z]of[[-1.2,-1.2],[1.2,-1.2],[-1.2,1.2],[1.2,1.2]]){const p=new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.15,4,8),slm);p.position.set(x,2,z);p.castShadow=true;sg.add(p);}
const slpl=new THREE.Mesh(new THREE.BoxGeometry(2.8,0.15,2.6),slm);slpl.position.set(0,4,-1.1);slpl.castShadow=true;sg.add(slpl);
const slramp=new THREE.Mesh(new THREE.BoxGeometry(2.8,0.15,4.5),new THREE.MeshStandardMaterial({color:0xffca28,roughness:0.6}));slramp.position.set(0,2,2.5);slramp.rotation.x=-0.45;slramp.castShadow=true;sg.add(slramp);

// Swings
const swg=new THREE.Group(); swg.position.set(22,0,10); scene.add(swg);
const swm=new THREE.MeshStandardMaterial({color:0x6d4c41,roughness:0.8});
const swtop=new THREE.Mesh(new THREE.BoxGeometry(9,0.2,0.2),swm);swtop.position.y=4.2;swtop.castShadow=true;swg.add(swtop);
[-4,4].forEach(x=>{const p=new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,4.2,8),swm);p.position.set(x,2.1,0);p.castShadow=true;swg.add(p);});
[-3,0,3].forEach(x=>{
  const seat=new THREE.Mesh(new THREE.BoxGeometry(0.65,0.1,0.4),new THREE.MeshStandardMaterial({color:0xef5350}));seat.position.set(x,1.4,0);seat.castShadow=true;swg.add(seat);
  [-0.25,0.25].forEach(cx=>{const ch=new THREE.Mesh(new THREE.CylinderGeometry(0.025,0.025,2.8,6),M.metal);ch.position.set(x+cx,2.8,0);swg.add(ch);});
});

// Merry-go-round
const mgg=new THREE.Group(); mgg.position.set(0,0,18); scene.add(mgg);
const mgpl=new THREE.Mesh(new THREE.CylinderGeometry(2.6,2.6,0.25,32),new THREE.MeshStandardMaterial({color:0xe91e63,roughness:0.6,metalness:0.3}));mgpl.position.y=0.12;mgpl.castShadow=true;mgg.add(mgpl);
const mgpole=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,1.5,8),M.metal);mgpole.position.y=0.75;mgg.add(mgpole);
for(let i=0;i<8;i++){const a=i/8*Math.PI*2;const sp=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,2.3,6),M.metal);sp.position.set(Math.cos(a)*1.1,0.25,Math.sin(a)*1.1);sp.rotation.z=Math.PI/2;sp.rotation.y=a;mgg.add(sp);}

// Trampoline
const tg=new THREE.Group(); tg.position.set(0,0,22); scene.add(tg);
cyl(2.2,2.2,0.15,32,new THREE.MeshStandardMaterial({color:0x1565c0,roughness:0.5}),0,0.4,0);
cyl(2.0,2.0,0.05,32,new THREE.MeshStandardMaterial({color:0x111111,roughness:0.3}),0,0.5,0);
for(let i=0;i<12;i++){const a=i/12*Math.PI*2;const leg=new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.5,6),M.metal);leg.position.set(Math.cos(a)*2.1,0.25,Math.sin(a)*2.1);tg.add(leg);}

// Trees
function makeTree(x,z){
  const h=4+Math.random()*3;
  cyl(0.18,0.28,h,8,new THREE.MeshStandardMaterial({color:0x4e342e,roughness:1}),x,h/2,z);
  sph(1.3+Math.random()*0.7,8,new THREE.MeshStandardMaterial({color:0x2e7d32,roughness:0.9}),x,h+1.1,z);
  sph(0.85,8,new THREE.MeshStandardMaterial({color:0x388e3c,roughness:0.9}),x+0.7,h+0.5,z+0.4);
  sph(0.85,8,new THREE.MeshStandardMaterial({color:0x1b5e20,roughness:0.9}),x-0.7,h+0.5,z-0.4);
}
for(let i=0;i<32;i++){const a=Math.random()*Math.PI*2,r=30+Math.random()*20;makeTree(Math.cos(a)*r,Math.sin(a)*r);}

// Lamp posts
function makeLamp(x,z){
  cyl(0.05,0.08,4.5,8,M.metal,x,2.25,z);
  const pt=new THREE.PointLight(0xfff8e1,1.5,14); pt.position.set(x,4.5,z); scene.add(pt);
  const g=new THREE.Mesh(new THREE.SphereGeometry(0.18,8,8),new THREE.MeshBasicMaterial({color:0xfff9c4}));g.position.set(x,4.5,z);scene.add(g);
}
for(const[x,z]of[[-8,0],[8,0],[0,-10],[0,12],[-15,6],[15,6],[-20,-5],[20,-5]])makeLamp(x,z);

// â”€â”€ VR GUN IN HAND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeVRGun(ctrl) {
  const g = new THREE.Group();
  const bm=new THREE.MeshStandardMaterial({color:0x1a237e,roughness:0.4,metalness:0.8});
  const hm=new THREE.MeshStandardMaterial({color:0x3e2723,roughness:0.85});
  const mm=new THREE.MeshStandardMaterial({color:0x37474f,roughness:0.3,metalness:0.9});
  const body=new THREE.Mesh(new THREE.BoxGeometry(0.065,0.09,0.52),bm);g.add(body);
  const handle=new THREE.Mesh(new THREE.BoxGeometry(0.055,0.13,0.075),hm);handle.position.set(0,-0.11,0.05);handle.rotation.x=0.3;g.add(handle);
  const barrel=new THREE.Mesh(new THREE.CylinderGeometry(0.016,0.016,0.32,8),mm);barrel.rotation.x=Math.PI/2;barrel.position.set(0,0.03,-0.26);g.add(barrel);
  const mag=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.1,0.065),hm);mag.position.set(0,-0.1,0.12);g.add(mag);
  const stock=new THREE.Mesh(new THREE.BoxGeometry(0.055,0.065,0.2),bm);stock.position.set(0,-0.01,0.3);g.add(stock);
  const scope=new THREE.Mesh(new THREE.CylinderGeometry(0.022,0.022,0.14,8),mm);scope.rotation.x=Math.PI/2;scope.position.set(0,0.075,-0.01);g.add(scope);
  // Muzzle flash
  const fl=new THREE.Mesh(new THREE.SphereGeometry(0.06,6,6),new THREE.MeshBasicMaterial({color:0xffff00,transparent:true,opacity:0}));
  fl.name='flash';fl.position.set(0,0,-0.46);g.add(fl);
  g.position.set(0,-0.01,-0.04);
  ctrl.add(g);
  return g;
}
vrControllers.forEach(c => makeVRGun(c));

// â”€â”€ DESKTOP GUN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const gunGroup = new THREE.Group();
camera.add(gunGroup);
gunGroup.position.set(0.22,-0.17,-0.42);
function buildDesktopGun() {
  gunGroup.clear();
  const bm=new THREE.MeshStandardMaterial({color:0x1a237e,roughness:0.4,metalness:0.8});
  const hm=new THREE.MeshStandardMaterial({color:0x3e2723,roughness:0.85});
  const mm=new THREE.MeshStandardMaterial({color:0x37474f,roughness:0.3,metalness:0.9});
  const body=new THREE.Mesh(new THREE.BoxGeometry(0.065,0.09,0.52),bm);gunGroup.add(body);
  const handle=new THREE.Mesh(new THREE.BoxGeometry(0.055,0.13,0.075),hm);handle.position.set(0,-0.11,0.05);handle.rotation.x=0.3;gunGroup.add(handle);
  const barrel=new THREE.Mesh(new THREE.CylinderGeometry(0.016,0.016,0.32,8),mm);barrel.rotation.x=Math.PI/2;barrel.position.set(0,0.03,-0.26);gunGroup.add(barrel);
  const mag=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.1,0.065),hm);mag.position.set(0,-0.1,0.12);gunGroup.add(mag);
  const stock=new THREE.Mesh(new THREE.BoxGeometry(0.055,0.065,0.2),bm);stock.position.set(0,-0.01,0.3);gunGroup.add(stock);
  const scope=new THREE.Mesh(new THREE.CylinderGeometry(0.022,0.022,0.14,8),mm);scope.rotation.x=Math.PI/2;scope.position.set(0,0.075,-0.01);gunGroup.add(scope);
  const fl=new THREE.Mesh(new THREE.SphereGeometry(0.06,6,6),new THREE.MeshBasicMaterial({color:0xffff00,transparent:true,opacity:0}));
  fl.name='flash';fl.position.set(0,0,-0.46);gunGroup.add(fl);
  const pl=new THREE.PointLight(0xffaa00,0,4);pl.name='mlight';gunGroup.add(pl);
}
buildDesktopGun();

// â”€â”€ BULLETS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const bulletGeo = new THREE.SphereGeometry(0.035,5,5);
const bulletMatY = new THREE.MeshBasicMaterial({color:0xffff00});
const bullets = [];
let desktopAmmo=30, desktopReloading=false, lastShot=0;

function desktopShoot() {
  const now = performance.now()/1000;
  if(desktopReloading||now-lastShot<0.09) return;
  if(desktopAmmo<=0){desktopDoReload();return;}
  lastShot=now; desktopAmmo--;
  updateHUD();
  const fl=gunGroup.getObjectByName('flash');
  const pl=gunGroup.getObjectByName('mlight');
  if(fl){fl.material.opacity=1;setTimeout(()=>fl.material.opacity=0,55);}
  if(pl){pl.intensity=4;setTimeout(()=>pl.intensity=0,55);}
  recoilZ=0.04;
  const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
  const pos=new THREE.Vector3();camera.getWorldPosition(pos);pos.addScaledVector(dir,0.5);
  const b=new THREE.Mesh(bulletGeo,bulletMatY.clone());
  b.position.copy(pos);
  b.userData={vel:dir.clone().multiplyScalar(85),life:2.5,alive:true};
  scene.add(b);bullets.push(b);
}

function desktopDoReload() {
  if(desktopReloading)return;
  desktopReloading=true;
  document.getElementById('ammo').textContent='RELOADING...';
  document.getElementById('reload-bar').style.display='block';
  const rf=document.getElementById('reload-fill');
  rf.style.transition='none';rf.style.width='0%';
  setTimeout(()=>{rf.style.transition='width 1.8s linear';rf.style.width='100%';},30);
  setTimeout(()=>{desktopAmmo=30;desktopReloading=false;document.getElementById('reload-bar').style.display='none';rf.style.width='0%';updateHUD();},1800);
}
function updateHUD(){
  if(!desktopReloading)document.getElementById('ammo').textContent=`${desktopAmmo} / 90`;
}

// â”€â”€ PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const particles=[];
function spawnParticles(pos,col=0xff6600,n=8){
  for(let i=0;i<n;i++){
    const p=new THREE.Mesh(new THREE.SphereGeometry(0.04+Math.random()*0.04,4,4),
      new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:1}));
    p.position.copy(pos);
    p.userData={vel:new THREE.Vector3((Math.random()-0.5)*10,Math.random()*8+3,(Math.random()-0.5)*10),life:0.6+Math.random()*0.4};
    scene.add(p);particles.push(p);
  }
}
function showHit(){const hm=document.getElementById('hitmarker');hm.classList.add('show');setTimeout(()=>hm.classList.remove('show'),110);}

// â”€â”€ NPCs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const npcs=[];
let waveNum=1, waveKills=0, waveTarget=5;
const npcColors=[0xf44336,0x2196f3,0x4caf50,0xffeb3b,0x9c27b0,0xff9800,0x00bcd4,0xe91e63];

class NPC {
  constructor(x,z,col,isBoss=false){
    this.alive=true; this.health=isBoss?500:100; this.maxHP=isBoss?500:100;
    this.color=col; this.isBoss=isBoss;
    this.g=new THREE.Group(); this.g.position.set(x,0,z); scene.add(this.g);
    const sc=isBoss?1.8:1;
    this.bm=new THREE.MeshStandardMaterial({color:col,roughness:0.7});
    this.body=new THREE.Mesh(new THREE.CylinderGeometry(0.27*sc,0.31*sc,1.15*sc,10),this.bm.clone());
    this.body.position.y=0.95*sc; this.body.castShadow=true; this.g.add(this.body);
    const hm2=new THREE.MeshStandardMaterial({color:isBoss?0xff6666:0xffcc99,roughness:0.7});
    this.headM=new THREE.Mesh(new THREE.SphereGeometry(0.22*sc,12,12),hm2);
    this.headM.position.y=1.65*sc; this.headM.castShadow=true; this.g.add(this.headM);
    const helMat=new THREE.MeshStandardMaterial({color:isBoss?0xb71c1c:0x37474f,roughness:0.4,metalness:0.6});
    const hel=new THREE.Mesh(new THREE.SphereGeometry(0.245*sc,12,8,0,Math.PI*2,0,Math.PI*0.6),helMat);
    hel.position.y=1.69*sc; this.g.add(hel);
    const am=new THREE.MeshStandardMaterial({color:col,roughness:0.7});
    this.lA=new THREE.Mesh(new THREE.CylinderGeometry(0.085*sc,0.075*sc,0.78*sc,8),am.clone());
    this.lA.position.set(-0.36*sc,0.9*sc,0);this.lA.rotation.z=0.4;this.lA.castShadow=true;this.g.add(this.lA);
    this.rA=this.lA.clone();this.rA.material=am.clone();this.rA.position.x=0.36*sc;this.rA.rotation.z=-0.4;this.g.add(this.rA);
    this.lL=new THREE.Mesh(new THREE.CylinderGeometry(0.09*sc,0.08*sc,0.82*sc,8),am.clone());
    this.lL.position.set(-0.17*sc,0.41*sc,0);this.lL.castShadow=true;this.g.add(this.lL);
    this.rL=this.lL.clone();this.rL.material=am.clone();this.rL.position.x=0.17*sc;this.g.add(this.rL);
    // gun
    const gm=new THREE.Mesh(new THREE.BoxGeometry(0.05*sc,0.05*sc,0.35*sc),
      new THREE.MeshStandardMaterial({color:0x212121,roughness:0.4,metalness:0.8}));
    gm.position.set(0.36*sc,0.9*sc,-0.2*sc);gm.rotation.x=-0.2;this.g.add(gm);
    // health bar
    this.hbg=new THREE.Group();this.hbg.position.y=(isBoss?3.6:2.3)*sc;this.g.add(this.hbg);
    const bgw=isBoss?1.2:0.72;
    const bg=new THREE.Mesh(new THREE.PlaneGeometry(bgw,0.12),new THREE.MeshBasicMaterial({color:0x222222}));this.hbg.add(bg);
    this.hbar=new THREE.Mesh(new THREE.PlaneGeometry(bgw-0.04,0.09),new THREE.MeshBasicMaterial({color:0x00e676}));
    this.hbar.position.z=0.01;this.hbg.add(this.hbar);
    this.t=Math.random()*100;this.dir=Math.random()*Math.PI*2;this.tdir=this.dir;
    this.shootTimer=Math.random()*3;
    npcs.push(this);
  }
  takeDamage(amt){
    if(!this.alive)return;
    this.health-=amt;const p=Math.max(0,this.health)/this.maxHP;
    this.hbar.scale.x=p;this.hbar.position.x=-(this.isBoss?0.58:0.34)*(1-p);
    this.hbar.material.color.setHex(p>0.5?0x00e676:p>0.25?0xffeb3b:0xff1744);
    if(this.health<=0)this.die();
    else{this.body.material.emissive.setHex(0xff0000);this.body.material.emissiveIntensity=0.7;setTimeout(()=>{this.body.material.emissive.setHex(0);this.body.material.emissiveIntensity=0;},140);}
  }
  die(){
    this.alive=false;
    const sc=document.getElementById('scoreVal');
    const kills=document.getElementById('kills');
    const pts=this.isBoss?1000:100;
    kills.textContent=parseInt(kills.textContent)+1;
    sc.textContent=parseInt(sc.textContent)+pts;
    waveKills++;
    this.g.rotation.x=Math.PI/2;this.hbg.visible=false;
    spawnParticles(this.g.position.clone(),this.color,this.isBoss?25:10);
    setTimeout(()=>{scene.remove(this.g);npcs.splice(npcs.indexOf(this),1);checkWave();},2500);
  }
  update(dt){
    if(!this.alive)return;
    this.t+=dt;
    this.lA.rotation.x=Math.sin(this.t*2.5)*0.4;this.rA.rotation.x=-Math.sin(this.t*2.5)*0.4;
    this.lL.rotation.x=Math.sin(this.t*3)*0.35;this.rL.rotation.x=-Math.sin(this.t*3)*0.35;
    this.g.position.y=Math.abs(Math.sin(this.t*4))*0.06;
    this.tdir+=(Math.random()-0.5)*0.05;this.dir+=(this.tdir-this.dir)*0.04;
    const spd=this.isBoss?2.2:1.6;
    this.g.position.x+=Math.cos(this.dir)*spd*dt;
    this.g.position.z+=Math.sin(this.dir)*spd*dt;
    if(Math.abs(this.g.position.x)>48||Math.abs(this.g.position.z)>48)this.tdir+=Math.PI;
    this.g.rotation.y=this.dir+Math.PI/2;
    this.hbg.quaternion.copy(camera.quaternion);
    // NPC shoots at player
    this.shootTimer-=dt;
    if(this.shootTimer<=0){
      this.shootTimer=this.isBoss?1.5:3+Math.random()*2;
      this.shootAtPlayer();
    }
    // Chase player
    const toPlayer=playerRig.position.clone().sub(this.g.position);
    if(toPlayer.length()<30){
      this.tdir=Math.atan2(toPlayer.z,toPlayer.x)-Math.PI/2;
    }
  }
  shootAtPlayer(){
    const toP=playerRig.position.clone().add(new THREE.Vector3(0,1.7,0)).sub(this.g.position.clone().add(new THREE.Vector3(0,1.5,0)));
    const dist=toP.length();
    if(dist>35)return;
    const dir=toP.normalize().add(new THREE.Vector3((Math.random()-0.5)*0.1,(Math.random()-0.5)*0.05,(Math.random()-0.5)*0.1)).normalize();
    const b=new THREE.Mesh(bulletGeo,new THREE.MeshBasicMaterial({color:0xff4444}));
    b.position.copy(this.g.position.clone().add(new THREE.Vector3(0,1.2,0)));
    b.userData={vel:dir.clone().multiplyScalar(28),life:3,alive:true,isNPC:true};
    scene.add(b);bullets.push(b);
  }
}

function spawnNPC(isBoss=false){
  const a=Math.random()*Math.PI*2,r=20+Math.random()*18;
  return new NPC(Math.cos(a)*r,Math.sin(a)*r,npcColors[Math.floor(Math.random()*npcColors.length)],isBoss);
}

function checkWave(){
  if(npcs.filter(n=>n.alive).length===0&&waveKills>=waveTarget){
    waveNum++;waveKills=0;waveTarget=Math.floor(waveNum*4+3);
    const banner=document.getElementById('wave-banner');
    banner.textContent=`WAVE ${waveNum}!`;banner.classList.add('show');
    document.getElementById('wave').textContent=waveNum;
    setTimeout(()=>banner.classList.remove('show'),2500);
    setTimeout(()=>{
      const count=Math.min(3+waveNum,15);
      for(let i=0;i<count;i++)spawnNPC();
      if(waveNum%5===0)spawnNPC(true); // boss every 5 waves
    },3000);
  }
}

for(let i=0;i<6;i++)spawnNPC();

// â”€â”€ RAYCASTER / HIT DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const sRay=new THREE.Raycaster();
function getHittables(){
  return[...npcs.filter(n=>n.alive).flatMap(n=>[n.body,n.headM]),
    ...targets.filter(t=>t.userData.alive),
    ...destructibles.map(d=>d.mesh).filter(m=>m.userData.alive),
    ...blocks.map(b=>b.mesh), ground];
}

function processBullet(b,hits){
  if(!hits.length)return false;
  const h=hits[0];const pos=h.point.clone();
  // NPC hit
  for(const n of npcs){
    if(!n.alive)continue;
    if(h.object===n.body||h.object===n.headM){
      if(b.userData.isNPC)return true; // NPC bullets don't hit NPCs
      const dmg=(h.object===n.headM?2.5:1)*(b.userData.isNPC?0:20);
      n.takeDamage(dmg);showHit();
      const sc=document.getElementById('scoreVal');sc.textContent=parseInt(sc.textContent)+Math.floor(dmg);
      spawnParticles(pos,0xff3333);return true;
    }
  }
  // Target hit
  for(const t of targets){
    if(!t.userData.alive)continue;
    if(h.object.parent===t||h.object===t){
      t.userData.health--;showHit();
      if(t.userData.health<=0){destroyTarget(t);}
      else spawnParticles(pos,0xff1744);
      return true;
    }
  }
  // Destructible brick
  for(const d of destructibles){
    if(h.object===d.mesh&&d.mesh.userData.alive){
      d.mesh.userData.alive=false;d.mesh.userData.falling=true;
      d.mesh.userData.vel.set((Math.random()-0.5)*4,Math.random()*5+2,(Math.random()-0.5)*4);
      d.mesh.userData.avel.set((Math.random()-0.5)*7,(Math.random()-0.5)*7,(Math.random()-0.5)*7);
      spawnParticles(pos,0xd84315);showHit();return true;
    }
  }
  // Block hit
  for(const bk of blocks){
    if(h.object===bk.mesh){
      bk.vel.addScaledVector(b.userData.vel.clone().normalize(),6);bk.vel.y+=2.5;bk.grounded=false;
      spawnParticles(pos,0x9e9e9e);showHit();return true;
    }
  }
  // Sword hit NPCs (while flying)
  for(const gr of grabbable){
    if(gr.type==='sword'&&h.object===gr.mesh&&gr.vel.length()>3){
      for(const n of npcs){
        if(!n.alive)continue;
        if(gr.mesh.position.distanceTo(n.g.position)<1.5){n.takeDamage(40);showHit();}
      }
    }
  }
  // Player hit by NPC bullet
  if(b.userData.isNPC&&h.object===ground){
    spawnParticles(pos,0x795548,4);return false;
  }
  if(b.userData.isNPC){
    const ppos=playerRig.position.clone().add(new THREE.Vector3(0,1.7,0));
    if(pos.distanceTo(ppos)<0.8){
      const hp=document.getElementById('hp');
      const v=Math.max(0,parseInt(hp.textContent)-10);
      hp.textContent=v;
      if(v<=0)showDeathScreen();
    }
  }
  spawnParticles(pos,0x795548,4);return false;
}

function destroyTarget(t){
  t.userData.alive=false;
  const sc=document.getElementById('scoreVal');sc.textContent=parseInt(sc.textContent)+50;
  spawnParticles(t.position.clone(),0xff1744);
  scene.remove(t);targets.splice(targets.indexOf(t),1);
  setTimeout(()=>{const nx=-14+Math.random()*28,nz=-20-Math.random()*20;makeTarget(nx,1.6,nz,Math.random()>0.5);},3500);
}

function showDeathScreen(){
  const o=document.getElementById('overlay');
  o.innerHTML='<h1 style="color:#ff1744">YOU DIED</h1><p>Reload the page to try again</p>';
  o.style.display='flex';
}

// â”€â”€ GRENADE EXPLOSION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function explodeGrabGrenade(phys){
  const pos=phys.mesh.position.clone();
  scene.remove(phys.mesh);
  grabbable.splice(grabbable.indexOf(phys),1);
  const fl=new THREE.Mesh(new THREE.SphereGeometry(5,10,10),new THREE.MeshBasicMaterial({color:0xff6600,transparent:true,opacity:0.8}));
  fl.position.copy(pos);scene.add(fl);
  const el=new THREE.PointLight(0xff6600,20,28);el.position.copy(pos);scene.add(el);
  spawnParticles(pos,0xff6600,22);
  setTimeout(()=>{scene.remove(fl);scene.remove(el);},200);
  const R=5.5;
  [...blocks,...destructibles.map(d=>({mesh:d.mesh,vel:d.mesh.userData.vel,avel:d.mesh.userData.avel,grounded:false}))].forEach(obj=>{
    const dist=(obj.mesh||obj).position.distanceTo(pos);
    if(dist<R){const f=(1-dist/R)*24,d2=(obj.mesh||obj).position.clone().sub(pos).normalize();
      if(obj.vel){obj.vel.addScaledVector(d2,f);obj.vel.y+=f*0.6;obj.grounded=false;}
      if(obj.mesh?.userData?.falling!==undefined){obj.mesh.userData.falling=true;obj.mesh.userData.alive=false;if(obj.mesh.userData.avel)obj.mesh.userData.avel.set((Math.random()-0.5)*10,(Math.random()-0.5)*10,(Math.random()-0.5)*10);}
    }
  });
  targets.forEach(t=>{if(t.userData.alive&&t.position.distanceTo(pos)<R)destroyTarget(t);});
  npcs.forEach(n=>{if(n.alive&&n.g.position.distanceTo(pos)<R)n.takeDamage(80+(5-n.g.position.distanceTo(pos))*10);});
}

// â”€â”€ SWORD HIT DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkSwordHits(){
  for(const gr of grabbable){
    if(gr.type!=='sword')continue;
    if(gr.vel.length()<3&&gr.heldBy===null)continue;
    for(const n of npcs){
      if(!n.alive)continue;
      if(gr.mesh.position.distanceTo(n.g.position)<1.4){
        n.takeDamage(gr.heldBy!==null?15:35);
        showHit();
        spawnParticles(gr.mesh.position.clone(),0xffd700,5);
      }
    }
  }
}

// â”€â”€ INPUT (Desktop) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const keys={};
let recoilZ=0;
window.addEventListener('keydown',e=>{
  keys[e.code]=true;
  if(e.code==='KeyR')desktopDoReload();
  if(e.code==='KeyF'){if(document.pointerLockElement)document.exitPointerLock();else renderer.domElement.requestPointerLock();}
  if(e.code==='KeyG'){
    // throw a grenade from player pos
    const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
    const g=makeGrenade(0,0,0);
    camera.getWorldPosition(g.mesh.position);
    g.vel.copy(dir.clone().multiplyScalar(12)).add(new THREE.Vector3(0,5,0));
    g.avel.set(Math.random()*6,Math.random()*6,Math.random()*6);
    g.armed=true;g.fuse=2.2;
  }
});
window.addEventListener('keyup',e=>keys[e.code]=false);

const yaw=new THREE.Euler(0,0,0,'YXZ');let pitch=0;
window.addEventListener('mousemove',e=>{
  if(document.pointerLockElement!==renderer.domElement)return;
  yaw.y-=e.movementX*0.002;pitch=Math.max(-1.2,Math.min(1.2,pitch-e.movementY*0.002));
});
renderer.domElement.addEventListener('click',()=>{if(document.pointerLockElement!==renderer.domElement)renderer.domElement.requestPointerLock();});
let autoFire=null;
window.addEventListener('mousedown',e=>{
  if(e.button!==0||document.pointerLockElement!==renderer.domElement)return;
  desktopShoot();autoFire=setInterval(desktopShoot,90);
});
window.addEventListener('mouseup',()=>{clearInterval(autoFire);autoFire=null;});

const pVel=new THREE.Vector3();let grounded=false;
function updateDesktopPlayer(dt){
  const fwd=new THREE.Vector3(-Math.sin(yaw.y),0,-Math.cos(yaw.y));
  const rgt=new THREE.Vector3(Math.cos(yaw.y),0,-Math.sin(yaw.y));
  const sp=keys['ShiftLeft']?1.8:1;
  if(keys['KeyW'])pVel.addScaledVector(fwd,5.5*sp*dt*3);
  if(keys['KeyS'])pVel.addScaledVector(fwd,-5.5*dt*3);
  if(keys['KeyA'])pVel.addScaledVector(rgt,-5.5*sp*dt*3);
  if(keys['KeyD'])pVel.addScaledVector(rgt,5.5*sp*dt*3);
  if(keys['Space']&&grounded){pVel.y=8;grounded=false;}
  pVel.y-=22*dt;pVel.x*=0.82;pVel.z*=0.82;
  playerRig.position.addScaledVector(pVel,dt);
  if(playerRig.position.y<0){playerRig.position.y=0;pVel.y=0;grounded=true;}
  camera.rotation.set(pitch,0,0);playerRig.rotation.y=yaw.y;
  if(recoilZ>0){gunGroup.position.z=-0.42+recoilZ*0.5;recoilZ*=0.72;if(recoilZ<0.001)recoilZ=0;}
  else gunGroup.position.z=-0.42;
  const tt=performance.now()*0.001;
  const mv=keys['KeyW']||keys['KeyA']||keys['KeyS']||keys['KeyD'];
  gunGroup.position.y=-0.17+(mv?Math.sin(tt*8)*0.007:Math.sin(tt*1.5)*0.003);
  gunGroup.position.x=0.22+(mv?Math.sin(tt*4)*0.005:0);
}

// â”€â”€ VR CHECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let isVR=false;
async function enterVR(){
  try{
    if(!navigator.xr){alert('WebXR not available in this browser.\nUse Oculus Browser, Firefox Reality, or Chrome with a connected headset.');return;}
    const supported=await navigator.xr.isSessionSupported('immersive-vr');
    if(!supported){alert('VR not supported on this device.\nConnect a VR headset and use a compatible browser.');return;}
    const session=await navigator.xr.requestSession('immersive-vr',{requiredFeatures:['local-floor'],optionalFeatures:['hand-tracking','bounded-floor']});
    await renderer.xr.setSession(session);
    isVR=true;
    document.getElementById('overlay').style.display='none';
    document.getElementById('hud').style.display='block';
    gunGroup.visible=false; // hide desktop gun in VR
  }catch(err){
    alert('Could not enter VR: '+err.message+'\n\nTry Desktop Mode instead.');
    console.error(err);
  }
}
window.enterVR=enterVR;

function enterDesktop(){
  document.getElementById('overlay').style.display='none';
  document.getElementById('hud').style.display='block';
  renderer.domElement.requestPointerLock();
}
window.enterDesktop=enterDesktop;

// Check VR availability on load
(async()=>{
  const statusEl=document.getElementById('vr-status');
  if(!navigator.xr){statusEl.textContent='âŒ WebXR not available â€” use Desktop Mode or Oculus/Firefox Reality browser';return;}
  try{
    const ok=await navigator.xr.isSessionSupported('immersive-vr');
    statusEl.textContent=ok?'âœ… VR headset detected! Ready to enter.':'âš ï¸ No VR headset detected â€” connect one or use Desktop Mode';
    document.getElementById('vr-btn').style.opacity=ok?'1':'0.5';
  }catch(e){statusEl.textContent='âš ï¸ VR check blocked â€” try Oculus Browser or connect headset first';}
})();

// VR locomotion (left thumbstick)
renderer.xr.addEventListener('sessionstart',()=>{
  const session=renderer.xr.getSession();
  session.addEventListener('inputsourceschange',()=>{});
});

// â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const clock=new THREE.Clock();
renderer.setAnimationLoop(()=>{
  const dt=Math.min(clock.getDelta(),0.05);
  const t=clock.getElapsedTime();

  if(!isVR && document.getElementById('hud').style.display==='block') updateDesktopPlayer(dt);

  // VR controller velocity tracking
  vrControllers.forEach((ctrl,i)=>{
    const cur=new THREE.Vector3().setFromMatrixPosition(ctrl.matrixWorld);
    if(dt>0) ctrlVel[i].subVectors(cur,ctrlPrevPos[i]).divideScalar(dt);
    ctrlPrevPos[i].copy(cur);
  });

  // VR thumbstick locomotion
  if(isVR){
    const session=renderer.xr.getSession();
    if(session){
      for(const src of session.inputSources){
        if(src.gamepad&&src.handedness==='left'){
          const ax=src.gamepad.axes;
          if(ax.length>=4){
            const fwd=new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            fwd.y=0;fwd.normalize();
            const rgt=new THREE.Vector3(1,0,0).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            rgt.y=0;rgt.normalize();
            playerRig.position.addScaledVector(fwd,-ax[3]*3*dt);
            playerRig.position.addScaledVector(rgt, ax[2]*3*dt);
          }
        }
        if(src.gamepad&&src.handedness==='right'){
          // Right thumbstick = snap turn
          const ax=src.gamepad.axes;
          if(ax.length>=4&&Math.abs(ax[2])>0.7){
            playerRig.rotation.y-=Math.sign(ax[2])*Math.PI/4;
          }
        }
      }
    }
  }

  // Bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    if(!b.userData.alive){scene.remove(b);bullets.splice(i,1);continue;}
    b.userData.life-=dt;
    if(b.userData.life<=0){b.userData.alive=false;continue;}
    b.position.addScaledVector(b.userData.vel,dt);
    b.userData.vel.y-=9.8*dt*0.2;
    sRay.set(b.position,b.userData.vel.clone().normalize());
    sRay.far=b.userData.vel.length()*dt*2.5;
    if(processBullet(b,sRay.intersectObjects(getHittables(),true)))b.userData.alive=false;
  }

  // Particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];p.userData.life-=dt;
    if(p.userData.life<=0){scene.remove(p);particles.splice(i,1);continue;}
    p.userData.vel.y-=22*dt;p.position.addScaledVector(p.userData.vel,dt);
    p.material.opacity=Math.max(0,p.userData.life/0.8);if(!p.material.transparent)p.material.transparent=true;
  }

  // Grabbable physics
  for(const gr of grabbable){
    if(gr.heldBy!==null)continue;
    if(gr.grounded&&gr.vel.length()<0.05)continue;
    gr.vel.y-=16*dt;
    gr.mesh.position.addScaledVector(gr.vel,dt);
    gr.mesh.rotation.x+=gr.avel.x*dt;gr.mesh.rotation.y+=gr.avel.y*dt;gr.mesh.rotation.z+=gr.avel.z*dt;
    gr.vel.multiplyScalar(0.98);gr.avel.multiplyScalar(0.96);
    if(gr.mesh.position.y<0.3){
      gr.mesh.position.y=0.3;gr.vel.y=Math.abs(gr.vel.y)*0.3;
      gr.vel.x*=0.75;gr.vel.z*=0.75;gr.avel.multiplyScalar(0.75);
      if(Math.abs(gr.vel.y)<0.06)gr.grounded=true;
    }
    // Armed grenade countdown
    if(gr.type==='grenade'&&gr.armed){
      gr.fuse-=dt;
      if(gr.fuse<=0)explodeGrabGrenade(gr);
    }
  }

  // Destructible bricks
  destructibles.forEach(({mesh:m})=>{
    if(!m.userData.falling)return;
    m.userData.vel.y-=16*dt;m.position.addScaledVector(m.userData.vel,dt);
    m.rotation.x+=m.userData.avel.x*dt;m.rotation.y+=m.userData.avel.y*dt;m.rotation.z+=m.userData.avel.z*dt;
    m.userData.vel.multiplyScalar(0.98);m.userData.avel.multiplyScalar(0.96);
    if(m.position.y<0.28){m.position.y=0.28;m.userData.vel.y=Math.abs(m.userData.vel.y)*0.28;m.userData.vel.x*=0.7;m.userData.vel.z*=0.7;m.userData.avel.multiplyScalar(0.75);}
  });

  // NPCs
  npcs.forEach(n=>n.update(dt));
  checkSwordHits();

  // Targets
  targets.forEach(tg=>{
    if(!tg.userData.alive)return;
    if(tg.userData.spin)tg.rotation.y+=tg.userData.spinSpeed*dt;
    if(tg.userData.moving)tg.position.x=tg.userData.baseX+Math.sin(t*tg.userData.speed+tg.userData.phase)*tg.userData.range;
  });

  mgg.rotation.y+=0.28*dt;

  renderer.render(scene,camera);
});

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
