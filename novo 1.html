<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Combat Playground with VR Mode</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
            background: #000;
        }
        #info { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            color: white; 
            background: rgba(0,0,0,0.8); 
            padding: 15px; 
            border-radius: 8px; 
            z-index: 100;
            max-width: 300px;
        }
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            font-size: 18px;
        }
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,0,0,0.9);
            color: white;
            padding: 20px;
            border-radius: 8px;
            display: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>üó°Ô∏è VR Combat Playground</strong><br>
        <span id="status">Loading...</span><br>
        <small>
        Desktop: Click swords to throw<br>
        VR: Use trigger to grab swords<br>
        Hit NPCs to damage them (20 HP)<br>
        Right-click drag: Rotate | Scroll: Zoom
        </small>
    </div>
    <div id="score">
        Enemies Defeated: <span id="kills">0</span><br>
        Active NPCs: <span id="npcsAlive">0</span>
    </div>
    <div id="error">Error loading. Press F12 to see console.</div>

    <script type="module">
        try {
            const statusEl = document.getElementById('status');
            statusEl.innerHTML = 'Importing libraries...';

            import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js';
            import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/controls/OrbitControls.js';
            import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/webxr/VRButton.js';
            import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/webxr/XRControllerModelFactory.js';

            statusEl.innerHTML = 'Setting up scene...';

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, 60);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 8);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Add VR Button
            const vrButton = VRButton.createButton(renderer);
            document.body.appendChild(vrButton);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.update();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(10, 20, 10);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.left = -25;
            sunLight.shadow.camera.right = 25;
            sunLight.shadow.camera.top = 25;
            sunLight.shadow.camera.bottom = -25;
            scene.add(sunLight);

            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(60, 60),
                new THREE.MeshStandardMaterial({ color: 0x4a7c59 })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const gridHelper = new THREE.GridHelper(60, 60, 0x000000, 0x000000);
            gridHelper.material.opacity = 0.15;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            const physicsObjects = [];
            const npcs = [];
            let draggedObject = null;
            let killCount = 0;

            class PhysicsObject {
                constructor(mesh, type = 'object') {
                    this.mesh = mesh;
                    this.type = type;
                    this.velocity = new THREE.Vector3();
                    this.angularVelocity = new THREE.Vector3();
                    this.isGrabbed = false;
                    this.lastHitTime = 0;
                    this.grabbedByController = null;
                    physicsObjects.push(this);
                }

                update(deltaTime) {
                    if (this.isGrabbed) return;
                    
                    this.velocity.y += -9.8 * deltaTime;
                    this.mesh.position.addScaledVector(this.velocity, deltaTime);
                    
                    const angle = this.angularVelocity.length() * deltaTime;
                    if (angle > 0) {
                        const axis = this.angularVelocity.clone().normalize();
                        this.mesh.rotateOnWorldAxis(axis, angle);
                    }
                    
                    if (this.mesh.position.y < 0.75) {
                        this.mesh.position.y = 0.75;
                        this.velocity.y = Math.abs(this.velocity.y) * 0.4;
                        this.velocity.x *= 0.7;
                        this.velocity.z *= 0.7;
                        this.angularVelocity.multiplyScalar(0.7);
                    }
                    
                    this.velocity.multiplyScalar(0.98);
                    this.angularVelocity.multiplyScalar(0.95);
                }

                grab(controller = null) { 
                    this.isGrabbed = true; 
                    this.velocity.set(0, 0, 0); 
                    this.angularVelocity.set(0, 0, 0);
                    this.grabbedByController = controller;
                }
                
                release(throwVelocity) { 
                    this.isGrabbed = false; 
                    this.velocity.copy(throwVelocity);
                    this.angularVelocity.set(
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 5
                    );
                    this.grabbedByController = null;
                }
            }

            class NPC {
                constructor(x, z, color, name) {
                    this.group = new THREE.Group();
                    this.health = 100;
                    this.color = color;
                    this.name = name;
                    this.isDead = false;
                    
                    this.bodyMaterial = new THREE.MeshStandardMaterial({ color });
                    this.body = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.35, 1.2, 12),
                        this.bodyMaterial
                    );
                    this.body.position.y = 1;
                    this.body.castShadow = true;
                    this.group.add(this.body);
                    
                    const head = new THREE.Mesh(
                        new THREE.SphereGeometry(0.28, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0xffdbac })
                    );
                    head.position.y = 1.8;
                    head.castShadow = true;
                    this.group.add(head);
                    
                    const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                    const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.06), eyeMaterial);
                    leftEye.position.set(-0.12, 1.85, 0.22);
                    this.group.add(leftEye);
                    
                    const rightEye = leftEye.clone();
                    rightEye.position.x = 0.12;
                    this.group.add(rightEye);
                    
                    this.leftArm = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.12, 0.1, 0.9, 8),
                        new THREE.MeshStandardMaterial({ color })
                    );
                    this.leftArm.position.set(-0.45, 1.1, 0);
                    this.leftArm.rotation.z = 0.4;
                    this.leftArm.castShadow = true;
                    this.group.add(this.leftArm);
                    
                    this.rightArm = this.leftArm.clone();
                    this.rightArm.material = this.leftArm.material.clone();
                    this.rightArm.position.x = 0.45;
                    this.rightArm.rotation.z = -0.4;
                    this.group.add(this.rightArm);
                    
                    this.healthBarGroup = new THREE.Group();
                    const healthBg = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 0.12),
                        new THREE.MeshBasicMaterial({ color: 0x333333 })
                    );
                    this.healthBarGroup.add(healthBg);
                    
                    this.healthBar = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.66, 0.1),
                        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                    );
                    this.healthBar.position.z = 0.01;
                    this.healthBarGroup.add(this.healthBar);
                    this.healthBarGroup.position.y = 2.4;
                    this.group.add(this.healthBarGroup);
                    
                    this.group.position.set(x, 0, z);
                    scene.add(this.group);
                    
                    this.time = Math.random() * 100;
                    this.walkSpeed = 0.4 + Math.random() * 0.3;
                    this.direction = Math.random() * Math.PI * 2;
                    this.targetDirection = this.direction;
                    
                    npcs.push(this);
                    updateNPCCount();
                }

                takeDamage(amount) {
                    if (this.isDead) return;
                    
                    this.health -= amount;
                    if (this.health < 0) this.health = 0;
                    
                    const healthPercent = this.health / 100;
                    this.healthBar.scale.x = healthPercent;
                    this.healthBar.position.x = -0.33 * (1 - healthPercent);
                    
                    if (healthPercent > 0.6) {
                        this.healthBar.material.color.setHex(0x00ff00);
                    } else if (healthPercent > 0.3) {
                        this.healthBar.material.color.setHex(0xffaa00);
                    } else {
                        this.healthBar.material.color.setHex(0xff0000);
                    }
                    
                    if (this.health <= 0) {
                        this.die();
                    } else {
                        this.bodyMaterial.color.setHex(0xffffff);
                        setTimeout(() => {
                            this.bodyMaterial.color.setHex(this.color);
                        }, 150);
                    }
                }

                die() {
                    this.isDead = true;
                    killCount++;
                    document.getElementById('kills').innerHTML = killCount;
                    
                    this.group.rotation.x = Math.PI / 2;
                    this.healthBarGroup.visible = false;
                    
                    setTimeout(() => {
                        scene.remove(this.group);
                        npcs.splice(npcs.indexOf(this), 1);
                        updateNPCCount();
                        setTimeout(() => spawnRandomNPC(), 3000);
                    }, 2000);
                }

                update(deltaTime) {
                    if (this.isDead) return;
                    
                    this.time += deltaTime;
                    this.leftArm.rotation.x = Math.sin(this.time * 3) * 0.4;
                    this.rightArm.rotation.x = -Math.sin(this.time * 3) * 0.4;
                    this.group.position.y = Math.abs(Math.sin(this.time * 5)) * 0.08;
                    
                    const dirDiff = this.targetDirection - this.direction;
                    this.direction += dirDiff * 0.05;
                    
                    this.group.position.x += Math.cos(this.direction) * this.walkSpeed * deltaTime;
                    this.group.position.z += Math.sin(this.direction) * this.walkSpeed * deltaTime;
                    
                    if (Math.abs(this.group.position.x) > 25 || Math.abs(this.group.position.z) > 25) {
                        this.targetDirection += Math.PI;
                    }
                    
                    if (Math.random() < 0.015) {
                        this.targetDirection += (Math.random() - 0.5) * Math.PI;
                    }
                    
                    this.group.rotation.y = this.direction + Math.PI / 2;
                    this.healthBarGroup.quaternion.copy(camera.quaternion);
                }
            }

            function createSword(x, y, z, bladeColor, handleColor) {
                const swordGroup = new THREE.Group();
                
                const blade = new THREE.Mesh(
                    new THREE.BoxGeometry(0.12, 1.8, 0.06),
                    new THREE.MeshStandardMaterial({ 
                        color: bladeColor,
                        metalness: 0.9,
                        roughness: 0.1
                    })
                );
                blade.position.y = 0.9;
                blade.castShadow = true;
                swordGroup.add(blade);
                
                const handle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.5, 12),
                    new THREE.MeshStandardMaterial({ color: handleColor })
                );
                handle.castShadow = true;
                swordGroup.add(handle);
                
                const guard = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.08, 0.12),
                    new THREE.MeshStandardMaterial({ color: 0x8b7355 })
                );
                guard.position.y = 0.25;
                swordGroup.add(guard);
                
                swordGroup.position.set(x, y, z);
                scene.add(swordGroup);
                
                return new PhysicsObject(swordGroup, 'sword');
            }

            function spawnRandomNPC() {
                const colors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0xff00ff, 0x00ffff];
                const names = ['Bob', 'Alice', 'Charlie', 'Diana', 'Eve', 'Frank'];
                const angle = Math.random() * Math.PI * 2;
                const distance = 15 + Math.random() * 8;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                const color = colors[Math.floor(Math.random() * colors.length)];
                const name = names[Math.floor(Math.random() * names.length)];
                new NPC(x, z, color, name);
            }

            function updateNPCCount() {
                document.getElementById('npcsAlive').innerHTML = npcs.length;
            }

            statusEl.innerHTML = 'Spawning NPCs...';
            for (let i = 0; i < 6; i++) {
                spawnRandomNPC();
            }

            statusEl.innerHTML = 'Creating swords...';
            createSword(-3, 1.5, 0, 0xff0000, 0x8b0000);
            createSword(3, 1.5, 0, 0x0000ff, 0x000088);
            createSword(0, 1.5, -3, 0x00ff00, 0x008800);
            createSword(0, 1.5, 3, 0xffff00, 0x888800);
            createSword(-2, 1.5, -2, 0xff00ff, 0x880088);
            createSword(2, 1.5, 2, 0x00ffff, 0x008888);

            function checkSwordCollisions() {
                const currentTime = Date.now();
                physicsObjects.forEach(obj => {
                    if (obj.type === 'sword' && obj.velocity.length() > 2.5) {
                        npcs.forEach(npc => {
                            if (!npc.isDead) {
                                const distance = obj.mesh.position.distanceTo(npc.group.position);
                                if (distance < 1.2 && currentTime - obj.lastHitTime > 300) {
                                    npc.takeDamage(20);
                                    obj.lastHitTime = currentTime;
                                }
                            }
                        });
                    }
                });
            }

            // VR CONTROLLERS
            const controllerModelFactory = new XRControllerModelFactory();
            const vrControllers = [];

            for (let i = 0; i < 2; i++) {
                const controller = renderer.xr.getController(i);
                controller.userData.grabbed = null;
                controller.userData.previousPosition = new THREE.Vector3();
                controller.userData.velocity = new THREE.Vector3();
                
                controller.addEventListener('selectstart', onVRSelectStart);
                controller.addEventListener('selectend', onVRSelectEnd);
                
                scene.add(controller);

                const grip = renderer.xr.getControllerGrip(i);
                grip.add(controllerModelFactory.createControllerModel(grip));
                scene.add(grip);

                const line = new THREE.Line(
                    new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(0, 0, -1)
                    ]),
                    new THREE.LineBasicMaterial({ color: 0xffffff })
                );
                line.scale.z = 5;
                controller.add(line);

                vrControllers.push(controller);
            }

            function onVRSelectStart(event) {
                const controller = event.target;
                const tempMatrix = new THREE.Matrix4();
                controller.updateMatrixWorld();
                tempMatrix.identity().extractRotation(controller.matrixWorld);

                const raycaster = new THREE.Raycaster();
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

                const intersects = raycaster.intersectObjects(physicsObjects.map(obj => obj.mesh), true);

                if (intersects.length > 0) {
                    let parentObj = intersects[0].object;
                    while (parentObj.parent && !parentObj.parent.isScene) {
                        parentObj = parentObj.parent;
                    }
                    
                    const physicsObj = physicsObjects.find(obj => obj.mesh === parentObj);
                    
                    if (physicsObj && !physicsObj.isGrabbed) {
                        physicsObj.grab(controller);
                        controller.userData.grabbed = physicsObj;
                        controller.attach(parentObj);
                    }
                }
            }

            function onVRSelectEnd(event) {
                const controller = event.target;
                
                if (controller.userData.grabbed) {
                    const physicsObj = controller.userData.grabbed;
                    const object = physicsObj.mesh;
                    
                    scene.attach(object);
                    
                    const throwVelocity = controller.userData.velocity.clone().multiplyScalar(3);
                    physicsObj.release(throwVelocity);
                    
                    controller.userData.grabbed = null;
                }
            }

            // DESKTOP MOUSE CONTROLS
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let dragPlane = new THREE.Plane();
            let dragOffset = new THREE.Vector3();
            let previousMousePosition = new THREE.Vector2();
            let mouseVelocity = new THREE.Vector2();

            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);

            function onMouseDown(event) {
                if (event.button !== 0) return;
                
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(
                    physicsObjects.map(obj => obj.mesh), 
                    true
                );
                
                if (intersects.length > 0) {
                    controls.enabled = false;
                    
                    let parentObj = intersects[0].object;
                    while (parentObj.parent && !parentObj.parent.isScene) {
                        parentObj = parentObj.parent;
                    }
                    
                    const physicsObj = physicsObjects.find(obj => obj.mesh === parentObj);
                    
                    if (physicsObj) {
                        draggedObject = physicsObj;
                        physicsObj.grab();
                        
                        const cameraDirection = new THREE.Vector3();
                        camera.getWorldDirection(cameraDirection);
                        dragPlane.setFromNormalAndCoplanarPoint(
                            cameraDirection, 
                            physicsObj.mesh.position
                        );
                        
                        const intersection = new THREE.Vector3();
                        raycaster.ray.intersectPlane(dragPlane, intersection);
                        dragOffset.subVectors(physicsObj.mesh.position, intersection);
                    }
                }
                
                previousMousePosition.set(event.clientX, event.clientY);
            }

            function onMouseMove(event) {
                if (draggedObject) {
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, camera);
                    
                    const intersection = new THREE.Vector3();
                    raycaster.ray.intersectPlane(dragPlane, intersection);
                    draggedObject.mesh.position.copy(intersection.add(dragOffset));
                    
                    mouseVelocity.set(
                        event.clientX - previousMousePosition.x,
                        event.clientY - previousMousePosition.y
                    );
                    previousMousePosition.set(event.clientX, event.clientY);
                }
            }

            function onMouseUp(event) {
                if (draggedObject) {
                    const throwVelocity = new THREE.Vector3(
                        mouseVelocity.x * 0.08,
                        -mouseVelocity.y * 0.08,
                        0
                    );
                    
                    const cameraRight = new THREE.Vector3();
                    const cameraUp = new THREE.Vector3();
                    camera.getWorldDirection(cameraRight);
                    cameraUp.copy(camera.up);
                    cameraRight.cross(cameraUp).normalize();
                    
                    const worldVelocity = new THREE.Vector3();
                    worldVelocity.addScaledVector(cameraRight, throwVelocity.x);
                    worldVelocity.addScaledVector(cameraUp, throwVelocity.y);
                    
                    draggedObject.release(worldVelocity);
                    draggedObject = null;
                    controls.enabled = true;
                }
            }

            const clock = new THREE.Clock();
            statusEl.innerHTML = 'Ready! Desktop: Click swords | VR: Press Enter VR button';

            function animate() {
                const deltaTime = Math.min(clock.getDelta(), 0.1);

                // Update VR controller velocities
                vrControllers.forEach(controller => {
                    const currentPosition = new THREE.Vector3();
                    currentPosition.setFromMatrixPosition(controller.matrixWorld);
                    
                    if (deltaTime > 0) {
                        controller.userData.velocity.subVectors(
                            currentPosition, 
                            controller.userData.previousPosition
                        ).divideScalar(deltaTime);
                    }
                    
                    controller.userData.previousPosition.copy(currentPosition);
                });
                
                physicsObjects.forEach(obj => obj.update(deltaTime));
                npcs.forEach(npc => npc.update(deltaTime));
                checkSwordCollisions();
                
                if (!renderer.xr.isPresenting) {
                    controls.update();
                }
                
                renderer.render(scene, camera);
            }

            renderer.setAnimationLoop(animate);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            console.log('‚úÖ Game loaded successfully!');

        } catch (error) {
            document.getElementById('error').style.display = 'block';
            document.getElementById('error').innerHTML = 'Error: ' + error.message + '<br>Check console (F12)';
            console.error('Error loading game:', error);
        }
    </script>
</body>
</html>
