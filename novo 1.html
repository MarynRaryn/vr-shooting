<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Playground with Physics</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #info { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; z-index: 100; }
        #vrButton { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; background: #1a73e8; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; z-index: 100; }
        #vrButton:hover { background: #1557b0; }
    </style>
</head>
<body>
    <div id="info">
        <strong>VR Playground</strong><br>
        Put on your VR headset and click Enter VR<br>
        Use controllers to grab and throw objects!<br>
        Trigger button to grab objects
    </div>
    <button id="vrButton">Enter VR</button>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/webxr/XRControllerModelFactory.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 0, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.6, 3);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.xr.enabled = true;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const vrButton = document.getElementById('vrButton');
        vrButton.onclick = () => {
            if (renderer.xr.getSession()) {
                renderer.xr.getSession().end();
            } else {
                navigator.xr.requestSession('immersive-vr', { 
                    requiredFeatures: ['local-floor'], 
                    optionalFeatures: ['hand-tracking'] 
                }).then(session => renderer.xr.setSession(session));
            }
        };

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(5, 10, 5);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4a7c59, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const gravity = -9.8;
        const physicsObjects = [];

        class PhysicsObject {
            constructor(mesh, mass = 1) {
                this.mesh = mesh;
                this.mass = mass;
                this.velocity = new THREE.Vector3();
                this.angularVelocity = new THREE.Vector3();
                this.isGrabbed = false;
                physicsObjects.push(this);
            }

            update(deltaTime) {
                if (this.isGrabbed) return;
                this.velocity.y += gravity * deltaTime;
                this.mesh.position.addScaledVector(this.velocity, deltaTime);
                const angle = this.angularVelocity.length() * deltaTime;
                if (angle > 0) {
                    const axis = this.angularVelocity.clone().normalize();
                    this.mesh.rotateOnWorldAxis(axis, angle);
                }
                const minY = 0.5;
                if (this.mesh.position.y < minY) {
                    this.mesh.position.y = minY;
                    this.velocity.y = Math.abs(this.velocity.y) * 0.5;
                    this.velocity.x *= 0.8;
                    this.velocity.z *= 0.8;
                    this.angularVelocity.multiplyScalar(0.8);
                }
                this.velocity.multiplyScalar(0.99);
                this.angularVelocity.multiplyScalar(0.98);
            }

            grab() { 
                this.isGrabbed = true; 
                this.velocity.set(0,0,0); 
                this.angularVelocity.set(0,0,0); 
            }
            
            release(throwVelocity) { 
                this.isGrabbed = false; 
                this.velocity.copy(throwVelocity); 
            }
        }

        function createBall(x, y, z, radius, color) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({ color, roughness: 0.5 });
            const ball = new THREE.Mesh(geometry, material);
            ball.position.set(x, y, z);
            ball.castShadow = true;
            scene.add(ball);
            return new PhysicsObject(ball, 0.5);
        }

        function createBox(x, y, z, size, color) {
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshStandardMaterial({ color, roughness: 0.7 });
            const box = new THREE.Mesh(geometry, material);
            box.position.set(x, y, z);
            box.castShadow = true;
            scene.add(box);
            return new PhysicsObject(box, 1);
        }

        function createCylinder(x, y, z, radius, height, color) {
            const geometry = new THREE.CylinderGeometry(radius, radius, height, 32);
            const material = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
            const cylinder = new THREE.Mesh(geometry, material);
            cylinder.position.set(x, y, z);
            cylinder.castShadow = true;
            scene.add(cylinder);
            return new PhysicsObject(cylinder, 0.8);
        }

        createBall(-2, 2, -3, 0.3, 0xff0000);
        createBall(-1, 2, -3, 0.3, 0x00ff00);
        createBall(0, 2, -3, 0.3, 0x0000ff);
        createBall(1, 2, -3, 0.3, 0xffff00);
        createBall(2, 2, -3, 0.3, 0xff00ff);
        createBox(-2, 1.5, -1, 0.4, 0xff6600);
        createBox(-1, 1.5, -1, 0.4, 0x6600ff);
        createBox(0, 1.5, -1, 0.4, 0x00ffff);
        createBox(1, 1.5, -1, 0.4, 0xff0066);
        createCylinder(-1.5, 1, 1, 0.2, 0.6, 0x99ff00);
        createCylinder(-0.5, 1, 1, 0.2, 0.6, 0xff9900);
        createCylinder(0.5, 1, 1, 0.2, 0.6, 0x0099ff);
        createCylinder(1.5, 1, 1, 0.2, 0.6, 0xff0099);

        const platformGeometry = new THREE.BoxGeometry(4, 0.3, 4);
        const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.position.set(0, 1, -2);
        platform.castShadow = true;
        scene.add(platform);

        const controllerModelFactory = new XRControllerModelFactory();
        const controllers = [];

        for (let i = 0; i < 2; i++) {
            const controller = renderer.xr.getController(i);
            controller.userData.grabbed = null;
            controller.userData.previousPosition = new THREE.Vector3();
            controller.userData.velocity = new THREE.Vector3();
            controller.addEventListener('selectstart', onSelectStart);
            controller.addEventListener('selectend', onSelectEnd);
            scene.add(controller);
            const grip = renderer.xr.getControllerGrip(i);
            grip.add(controllerModelFactory.createControllerModel(grip));
            scene.add(grip);
            const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
            const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xffffff }));
            line.scale.z = 5;
            controller.add(line);
            controllers.push(controller);
        }

        function onSelectStart(event) {
            const controller = event.target;
            const tempMatrix = new THREE.Matrix4();
            controller.updateMatrixWorld();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            const raycaster = new THREE.Raycaster();
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0,0,-1).applyMatrix4(tempMatrix);
            const intersects = raycaster.intersectObjects(physicsObjects.map(obj => obj.mesh));
            if (intersects.length > 0) {
                const object = intersects[0].object;
                const physicsObj = physicsObjects.find(obj => obj.mesh === object);
                if (physicsObj && !physicsObj.isGrabbed) {
                    physicsObj.grab();
                    controller.userData.grabbed = physicsObj;
                    controller.attach(object);
                }
            }
        }

        function onSelectEnd(event) {
            const controller = event.target;
            if (controller.userData.grabbed) {
                const physicsObj = controller.userData.grabbed;
                const object = physicsObj.mesh;
                scene.attach(object);
                const throwVelocity = controller.userData.velocity.clone().multiplyScalar(3);
                physicsObj.release(throwVelocity);
                controller.userData.grabbed = null;
            }
        }

        const clock = new THREE.Clock();
        function animate() {
            const deltaTime = clock.getDelta();
            controllers.forEach(controller => {
                const currentPosition = new THREE.Vector3();
                currentPosition.setFromMatrixPosition(controller.matrixWorld);
                controller.userData.velocity.subVectors(currentPosition, controller.userData.previousPosition).divideScalar(deltaTime);
                controller.userData.previousPosition.copy(currentPosition);
            });
            physicsObjects.forEach(obj => obj.update(deltaTime));
            renderer.render(scene, camera);
        }
        renderer.setAnimationLoop(animate);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
